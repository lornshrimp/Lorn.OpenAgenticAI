# æœ¬åœ°æ•°æ®ç®¡ç†æŠ€æœ¯è®¾è®¡æ–‡æ¡£

## æ–‡æ¡£ä¿¡æ¯

- **æ–‡æ¡£ç‰ˆæœ¬**: v2.0
- **åˆ›å»ºæ—¥æœŸ**: 2025å¹´7æœˆ24æ—¥
- **ä½œè€…**: æŠ€æœ¯ä¸“å®¶
- **æ–‡æ¡£ç±»å‹**: æœ¬åœ°æ•°æ®ç®¡ç†æŠ€æœ¯è®¾è®¡
- **ä¾èµ–æ–‡æ¡£**: 
  - [æ•°æ®è®¿é—®å±‚ç»¼åˆæŠ€æœ¯è®¾è®¡](../../docs_TecDesign/DataAccessLayerDesign.md)
  - [æŒä¹…åŒ–æ•°æ®ç»“æ„æŠ€æœ¯è®¾è®¡](../../docs_TecDesign/PersistentDataStructureDesign.md)
  - [æŠ€æœ¯æ¶æ„è®¾è®¡](../../docs_TecDesign/TechnicalArchitecture.md)

## æ¦‚è¿°

æœ¬æ–‡æ¡£åŸºäºå·²æœ‰çš„æŠ€æœ¯æ¶æ„è®¾è®¡ï¼Œè¯¦ç»†æè¿°æœ¬åœ°æ•°æ®ç®¡ç†åŠŸèƒ½çš„å…·ä½“æŠ€æœ¯å®ç°æ–¹æ¡ˆã€‚ä½œä¸ºğŸ”´æ ¸å¿ƒåŸºç¡€è®¾æ–½çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œæœ¬åœ°æ•°æ®ç®¡ç†ä¸ºç³»ç»Ÿæ‰€æœ‰åŠŸèƒ½æä¾›å¯é çš„æ•°æ®å­˜å‚¨åŸºç¡€ï¼Œé‡‡ç”¨æ•°æ®åº“æ— å…³æ¶æ„è®¾è®¡ï¼Œæ”¯æŒé«˜æ€§èƒ½ã€é«˜å¯é æ€§å’Œé«˜å®‰å…¨æ€§çš„æ•°æ®ç®¡ç†éœ€æ±‚ã€‚

## æŠ€æœ¯æ¶æ„å®šä½

### åœ¨æ•´ä½“æ¶æ„ä¸­çš„ä½ç½®

```mermaid
graph TB
    subgraph "åº”ç”¨å±‚ (Application Layer)"
        APP[åº”ç”¨æœåŠ¡<br/>Application Services]
    end
    
    subgraph "é¢†åŸŸå±‚ (Domain Layer)"
        DOMAIN[é¢†åŸŸæ¨¡å‹<br/>Domain Models<br/>ğŸš« æ— æŠ€æœ¯ä¾èµ–]
    end
    
    subgraph "å…±äº«å±‚ (Shared Layer)"
        CONTRACTS[å…±äº«å¥‘çº¦<br/>Shared Contracts<br/>ğŸš« æ— æŠ€æœ¯ä¾èµ–]
    end
    
    subgraph "åŸºç¡€è®¾æ–½å±‚ (Infrastructure Layer)"
        DATA_ABSTRACT[æ•°æ®æŠ½è±¡å±‚<br/>Infrastructure.Data<br/>ğŸ“¦ EF Core æŠ½è±¡]
        DATA_REPO[ä»“å‚¨å±‚<br/>Infrastructure.Data.Repositories<br/>ğŸ“¦ ä»“å‚¨å®ç°]
        DATA_SPEC[è§„çº¦å±‚<br/>Infrastructure.Data.Specifications<br/>ğŸš« çº¯LINQ]
        DATA_SQLITE[SQLiteå®ç°<br/>Infrastructure.Data.Sqlite<br/>ğŸ“¦ SQLiteç‰¹å®š]
    end
    
    subgraph "æ•°æ®å­˜å‚¨å±‚ (Data Storage Layer)"
        SQLITE[(SQLite æ•°æ®åº“)]
        JSON_FILE[JSONé…ç½®æ–‡ä»¶]
        MEMORY_CACHE[å†…å­˜ç¼“å­˜]
    end
    
    %% ä¾èµ–å…³ç³» - ç¬¦åˆæ•°æ®åº“æ— å…³åŸåˆ™
    APP --> DOMAIN
    APP --> CONTRACTS
    APP --> DATA_REPO
    
    DATA_ABSTRACT --> DOMAIN
    DATA_ABSTRACT --> CONTRACTS
    
    DATA_SQLITE --> DATA_ABSTRACT
    DATA_SQLITE --> DOMAIN
    DATA_SQLITE --> SQLITE
    
    DATA_REPO --> DATA_ABSTRACT
    DATA_REPO --> DOMAIN
    DATA_REPO --> DATA_SPEC
    
    DATA_SPEC --> DOMAIN
    
    %% æ³¨å…¥å…³ç³»ï¼ˆè¿è¡Œæ—¶é€šè¿‡DIå®¹å™¨é…ç½®ï¼‰
    APP -.-> DATA_SQLITE
    DATA_REPO -.-> DATA_SQLITE
    
    %% å…¶ä»–å­˜å‚¨ç±»å‹
    DATA_ABSTRACT --> JSON_FILE
    DATA_ABSTRACT --> MEMORY_CACHE
    
    %% æ ·å¼
    style DOMAIN fill:#e1f5fe,stroke:#01579b,stroke-width:3px
    style CONTRACTS fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px
    style DATA_ABSTRACT fill:#f3e5f5,stroke:#4a148c,stroke-width:3px
    style DATA_SQLITE fill:#fff3e0,stroke:#e65100,stroke-width:3px
    style DATA_REPO fill:#fff3e0,stroke:#e65100,stroke-width:3px
    style DATA_SPEC fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
```

### Visual Studioé¡¹ç›®ç»“æ„ 

æœ¬è®¾è®¡æ¶‰åŠä»¥ä¸‹é¡¹ç›®çš„å®ç°ï¼š

```text
Lorn.OpenAgenticAI.sln
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ 3.Domain/
â”‚   â”‚   â””â”€â”€ Lorn.OpenAgenticAI.Domain.Models/          # é¢†åŸŸå®ä½“ç±»å®šä¹‰
â”‚   â”‚
â”‚   â”œâ”€â”€ 4.Infrastructure/
â”‚   â”‚   â”œâ”€â”€ Lorn.OpenAgenticAI.Infrastructure.Data/    # æ•°æ®è®¿é—®åŸºç¡€è®¾æ–½
â”‚   â”‚   â””â”€â”€ Lorn.OpenAgenticAI.Infrastructure.Data.Sqlite/  # SQLiteå…·ä½“å®ç°
â”‚   â”‚
â”‚   â””â”€â”€ 6.Shared/
â”‚       â”œâ”€â”€ Lorn.OpenAgenticAI.Shared.Contracts/       # æ¥å£å®šä¹‰
â”‚       â””â”€â”€ Lorn.OpenAgenticAI.Shared.Models/          # å…±äº«æ¨¡å‹
```

## æ•°æ®åº“æ— å…³æ¶æ„è®¾è®¡

### æ ¸å¿ƒè®¾è®¡åŸåˆ™

#### 1. æ•°æ®åº“æ— å…³æ€§ (Database Agnostic)

**ç›®æ ‡**: ä¸šåŠ¡é€»è¾‘ä¸ä¾èµ–ç‰¹å®šæ•°æ®åº“æŠ€æœ¯

**å®ç°æ–¹å¼**:
- `Infrastructure.Data` é¡¹ç›®åªå¼•ç”¨ EF Core æŠ½è±¡åŒ…
- å…·ä½“æ•°æ®åº“å®ç°ç‹¬ç«‹åœ¨ä¸“é—¨é¡¹ç›®ä¸­
- é€šè¿‡ä¾èµ–æ³¨å…¥åˆ‡æ¢æ•°æ®åº“æä¾›ç¨‹åº

**å…³é”®è®¾è®¡è¦ç‚¹**:
- âœ… **åº”ç”¨å±‚**ä»…ä¾èµ–æŠ½è±¡æ¥å£å’Œä»“å‚¨å±‚
- âœ… **ä»“å‚¨å±‚**ä¾èµ–æŠ½è±¡DbContextï¼Œä¸ä¾èµ–å…·ä½“æ•°æ®åº“å®ç°
- âœ… **å…·ä½“æ•°æ®åº“å®ç°**é€šè¿‡ä¾èµ–æ³¨å…¥åœ¨è¿è¡Œæ—¶é…ç½®
- âŒ **åº”ç”¨å±‚ç»ä¸ç›´æ¥å¼•ç”¨**å…·ä½“æ•°æ®åº“å®ç°é¡¹ç›®

#### 2. é¡¹ç›®ä¾èµ–å…³ç³»

```mermaid
graph TB
    subgraph "Domain Layer (é¢†åŸŸå±‚)"
        DOMAIN[Lorn.OpenAgenticAI.Domain.Models<br/>ğŸ“¦ ä¸šåŠ¡å®ä½“ã€å€¼å¯¹è±¡ã€æšä¸¾<br/>ğŸš« ä¸å¼•ç”¨EF Core]
    end
    
    subgraph "Shared Layer (å…±äº«å±‚)"
        CONTRACTS[Lorn.OpenAgenticAI.Shared.Contracts<br/>ğŸ“¦ DTOã€æ¥å£å®šä¹‰<br/>ğŸš« ä¸å¼•ç”¨EF Core]
    end
    
    subgraph "Infrastructure Layer (åŸºç¡€è®¾æ–½å±‚)"
        DATA[Lorn.OpenAgenticAI.Infrastructure.Data<br/>ğŸ“¦ EF CoreæŠ½è±¡ä¸Šä¸‹æ–‡ã€é…ç½®<br/>âœ… å¼•ç”¨EF CoreæŠ½è±¡]
        SQLITE[Lorn.OpenAgenticAI.Infrastructure.Data.Sqlite<br/>ğŸ“¦ SQLiteå…·ä½“å®ç°<br/>âœ… å¼•ç”¨EF Core SQLite]
        REPO[Lorn.OpenAgenticAI.Infrastructure.Data.Repositories<br/>ğŸ“¦ ä»“å‚¨å®ç°<br/>âœ… å¼•ç”¨EF Core]
        SPEC[Lorn.OpenAgenticAI.Infrastructure.Data.Specifications<br/>ğŸ“¦ æŸ¥è¯¢è§„çº¦<br/>ğŸš« ä¸å¼•ç”¨EF Core]
    end
    
    %% é¡¹ç›®å¼•ç”¨å…³ç³»
    DATA --> DOMAIN
    DATA --> CONTRACTS
    SQLITE --> DATA
    SQLITE --> DOMAIN
    REPO --> DATA
    REPO --> DOMAIN
    REPO --> SPEC
    SPEC --> DOMAIN
    
    %% æ ·å¼è®¾ç½®
    style DOMAIN fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    style CONTRACTS fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px
    style DATA fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    style SQLITE fill:#fff3e0,stroke:#e65100,stroke-width:3px
    style REPO fill:#fff3e0,stroke:#e65100,stroke-width:3px
    style SPEC fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
```

#### 3. Entity Framework Core å¼•ç”¨è¯¦æƒ…

| é¡¹ç›®                                                      | æ˜¯å¦éœ€è¦EF Core | å¼•ç”¨çš„EF CoreåŒ…                                                                                                             | è¯´æ˜                           |
| --------------------------------------------------------- | --------------- | --------------------------------------------------------------------------------------------------------------------------- | ------------------------------ |
| **Lorn.OpenAgenticAI.Domain.Models**                      | âŒ **ä¸éœ€è¦**    | æ—                                                                                                                           | çº¯é¢†åŸŸæ¨¡å‹ï¼Œä¸ä¾èµ–ä»»ä½•ORMæ¡†æ¶  |
| **Lorn.OpenAgenticAI.Shared.Contracts**                   | âŒ **ä¸éœ€è¦**    | æ—                                                                                                                           | çº¯DTOå’Œæ¥å£å®šä¹‰                |
| **Lorn.OpenAgenticAI.Infrastructure.Data**                | âœ… **éœ€è¦**      | `Microsoft.EntityFrameworkCore`<br/>`Microsoft.EntityFrameworkCore.Abstractions`                                            | EF CoreæŠ½è±¡æ¥å£å’Œé€šç”¨åŠŸèƒ½      |
| **Lorn.OpenAgenticAI.Infrastructure.Data.Sqlite**         | âœ… **éœ€è¦**      | `Microsoft.EntityFrameworkCore.Sqlite`<br/>`Microsoft.EntityFrameworkCore.Tools`<br/>`Microsoft.EntityFrameworkCore.Design` | SQLiteå…·ä½“å®ç°å’Œå·¥å…·           |
| **Lorn.OpenAgenticAI.Infrastructure.Data.Repositories**   | âœ… **éœ€è¦**      | `Microsoft.EntityFrameworkCore`                                                                                             | ä»“å‚¨å®ç°éœ€è¦ä½¿ç”¨DbContext      |
| **Lorn.OpenAgenticAI.Infrastructure.Data.Specifications** | âŒ **ä¸éœ€è¦**    | æ—                                                                                                                           | çº¯æŸ¥è¯¢è§„çº¦æ¨¡å¼ï¼Œä½¿ç”¨LINQè¡¨è¾¾å¼ |

### æ ¸å¿ƒç»„ä»¶è®¾è®¡

#### 1. æŠ½è±¡æ•°æ®ä¸Šä¸‹æ–‡

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data/OpenAgenticAIDbContext.cs`

```csharp
/// <summary>
/// æŠ½è±¡æ•°æ®åº“ä¸Šä¸‹æ–‡ï¼Œå®šä¹‰é€šç”¨DbSetså’Œé…ç½®
/// </summary>
public abstract class OpenAgenticAIDbContext : DbContext
{
    // ç”¨æˆ·ç®¡ç†ç›¸å…³
    public DbSet<UserProfile> UserProfiles { get; set; }
    public DbSet<UserPreferences> UserPreferences { get; set; }
    
    // ä»»åŠ¡æ‰§è¡Œç›¸å…³
    public DbSet<TaskExecutionHistory> TaskExecutionHistories { get; set; }
    public DbSet<ExecutionStepRecord> ExecutionStepRecords { get; set; }
    
    // LLMç®¡ç†ç›¸å…³
    public DbSet<ModelProvider> ModelProviders { get; set; }
    public DbSet<Model> Models { get; set; }
    public DbSet<ProviderUserConfiguration> ProviderUserConfigurations { get; set; }
    public DbSet<ModelUserConfiguration> ModelUserConfigurations { get; set; }
    
    // MCPé…ç½®ç›¸å…³
    public DbSet<MCPConfiguration> MCPConfigurations { get; set; }
    public DbSet<ProtocolAdapterConfiguration> ProtocolAdapterConfigurations { get; set; }
    
    // å·¥ä½œæµç›¸å…³
    public DbSet<WorkflowTemplate> WorkflowTemplates { get; set; }
    public DbSet<WorkflowExecution> WorkflowExecutions { get; set; }
    
    // Agentç®¡ç†ç›¸å…³
    public DbSet<AgentCapabilityRegistry> AgentCapabilityRegistries { get; set; }
    public DbSet<AgentActionDefinition> AgentActionDefinitions { get; set; }
    
    protected OpenAgenticAIDbContext(DbContextOptions options) : base(options) { }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // åº”ç”¨é€šç”¨é…ç½®
        ApplyCommonConfigurations(modelBuilder);
        base.OnModelCreating(modelBuilder);
    }
    
    /// <summary>
    /// åº”ç”¨é€šç”¨å®ä½“é…ç½®
    /// </summary>
    private void ApplyCommonConfigurations(ModelBuilder modelBuilder)
    {
        // åº”ç”¨æ‰€æœ‰å®ä½“é…ç½®
        modelBuilder.ApplyConfigurationsFromAssembly(typeof(OpenAgenticAIDbContext).Assembly);
        
        // å…¨å±€æŸ¥è¯¢è¿‡æ»¤å™¨
        modelBuilder.Entity<UserProfile>().HasQueryFilter(u => u.IsActive);
        
        // å…¨å±€å€¼è½¬æ¢å™¨
        foreach (var entityType in modelBuilder.Model.GetEntityTypes())
        {
            // DateTime ç»Ÿä¸€ä½¿ç”¨ UTC
            foreach (var property in entityType.GetProperties())
            {
                if (property.ClrType == typeof(DateTime) || property.ClrType == typeof(DateTime?))
                {
                    property.SetValueConverter(new ValueConverter<DateTime, DateTime>(
                        v => v.ToUniversalTime(),
                        v => DateTime.SpecifyKind(v, DateTimeKind.Utc)));
                }
            }
        }
    }
}
```

#### 2. SQLiteå…·ä½“å®ç°

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data.Sqlite/SqliteOpenAgenticAIDbContext.cs`

```csharp
/// <summary>
/// SQLiteæ•°æ®åº“ä¸Šä¸‹æ–‡å…·ä½“å®ç°
/// </summary>
public class SqliteOpenAgenticAIDbContext : OpenAgenticAIDbContext
{
    public SqliteOpenAgenticAIDbContext(DbContextOptions<SqliteOpenAgenticAIDbContext> options)
        : base(options) { }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        if (!optionsBuilder.IsConfigured)
        {
            // é»˜è®¤é…ç½®ï¼ˆé€šå¸¸é€šè¿‡DIé…ç½®ï¼Œè¿™é‡Œä½œä¸ºåå¤‡ï¼‰
            optionsBuilder.UseSqlite("Data Source=openagenticai.db");
        }
        
        // SQLiteç‰¹å®šä¼˜åŒ–
        optionsBuilder.EnableSensitiveDataLogging(false);
        optionsBuilder.EnableServiceProviderCaching();
        base.OnConfiguring(optionsBuilder);
    }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        
        // åº”ç”¨SQLiteç‰¹å®šé…ç½®
        ApplySqliteConfigurations(modelBuilder);
    }
    
    /// <summary>
    /// åº”ç”¨SQLiteç‰¹å®šé…ç½®
    /// </summary>
    private void ApplySqliteConfigurations(ModelBuilder modelBuilder)
    {
        // JSONåˆ—é…ç½®ï¼ˆSQLite 3.38+æ”¯æŒJSONï¼‰
        modelBuilder.Entity<UserProfile>()
            .Property(e => e.Metadata)
            .HasConversion(
                v => JsonSerializer.Serialize(v, JsonSerializerOptions.Default),
                v => JsonSerializer.Deserialize<Dictionary<string, object>>(v, JsonSerializerOptions.Default));
                
        modelBuilder.Entity<TaskExecutionHistory>()
            .Property(e => e.MetadataJson)
            .HasConversion(
                v => JsonSerializer.Serialize(v, JsonSerializerOptions.Default),
                v => JsonSerializer.Deserialize<Dictionary<string, object>>(v, JsonSerializerOptions.Default));
        
        // SQLiteä¸æ”¯æŒå¤šåˆ—å¤–é”®ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†
        modelBuilder.Entity<UserPreferences>()
            .HasIndex(e => new { e.UserId, e.PreferenceCategory, e.PreferenceKey })
            .IsUnique();
            
        // SQLiteæ—¥æœŸæ—¶é—´é…ç½®
        modelBuilder.Entity<TaskExecutionHistory>()
            .Property(e => e.StartTime)
            .HasConversion(new DateTimeToStringConverter());
    }
}
```

#### 3. æœåŠ¡æ³¨å†Œæ‰©å±•

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data.Sqlite/ServiceCollectionExtensions.cs`

```csharp
/// <summary>
/// SQLiteæ•°æ®åº“æœåŠ¡æ³¨å†Œæ‰©å±•
/// </summary>
public static class SqliteServiceCollectionExtensions
{
    /// <summary>
    /// æ³¨å†ŒSQLiteæ•°æ®åº“æœåŠ¡
    /// </summary>
    public static IServiceCollection AddSqliteDatabase(
        this IServiceCollection services, 
        string connectionString,
        Action<DbContextOptionsBuilder> optionsAction = null)
    {
        services.AddDbContext<OpenAgenticAIDbContext, SqliteOpenAgenticAIDbContext>(options =>
        {
            options.UseSqlite(connectionString, sqliteOptions =>
            {
                sqliteOptions.MigrationsAssembly("Lorn.OpenAgenticAI.Infrastructure.Data.Sqlite");
                sqliteOptions.CommandTimeout(30);
            });
            
            // åº”ç”¨é¢å¤–é…ç½®
            optionsAction?.Invoke(options);
        });
        
        // æ³¨å†Œæ•°æ®åº“åˆå§‹åŒ–æœåŠ¡
        services.AddScoped<IDatabaseInitializer, SqliteDatabaseInitializer>();
        
        return services;
    }
    
    /// <summary>
    /// ä»é…ç½®æ³¨å†ŒSQLiteæ•°æ®åº“æœåŠ¡
    /// </summary>
    public static IServiceCollection AddSqliteDatabase(
        this IServiceCollection services, 
        IConfiguration configuration,
        string connectionStringName = "DefaultConnection")
    {
        var connectionString = configuration.GetConnectionString(connectionStringName);
        if (string.IsNullOrEmpty(connectionString))
        {
            throw new InvalidOperationException($"Connection string '{connectionStringName}' not found.");
        }
        
        return services.AddSqliteDatabase(connectionString);
    }
}
```

## é¢†åŸŸå®ä½“è®¾è®¡

### 1. ç”¨æˆ·ç®¡ç†å®ä½“

#### 1.1 ç”¨æˆ·æ¡£æ¡ˆå®ä½“

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Domain.Models/UserManagement/UserProfile.cs`

```csharp
/// <summary>
/// ç”¨æˆ·æ¡£æ¡ˆèšåˆæ ¹
/// </summary>
public class UserProfile : IAggregateRoot
{
    public Guid UserId { get; private set; }
    public string Username { get; private set; }
    public string Email { get; private set; }
    public DateTime CreatedTime { get; private set; }
    public DateTime LastLoginTime { get; private set; }
    public bool IsActive { get; private set; }
    public int ProfileVersion { get; private set; }
    
    // å€¼å¯¹è±¡
    public SecuritySettings SecuritySettings { get; private set; }
    
    // JSONå­˜å‚¨çš„å¤æ‚å±æ€§
    public Dictionary<string, object> Metadata { get; private set; } = new();
    
    // å¯¼èˆªå±æ€§
    public virtual ICollection<UserPreferences> UserPreferences { get; private set; } = new List<UserPreferences>();
    public virtual ICollection<TaskExecutionHistory> ExecutionHistories { get; private set; } = new List<TaskExecutionHistory>();
    public virtual ICollection<WorkflowTemplate> WorkflowTemplates { get; private set; } = new List<WorkflowTemplate>();
    
    // ç§æœ‰æ„é€ å‡½æ•°ï¼ˆEF Coreéœ€è¦ï¼‰
    private UserProfile() { }
    
    // å·¥å‚æ–¹æ³•
    public static UserProfile Create(string username, string email)
    {
        return new UserProfile
        {
            UserId = Guid.NewGuid(),
            Username = username,
            Email = email,
            CreatedTime = DateTime.UtcNow,
            IsActive = true,
            ProfileVersion = 1,
            SecuritySettings = SecuritySettings.CreateDefault()
        };
    }
    
    // é¢†åŸŸæ–¹æ³•
    public void UpdateLastLogin()
    {
        LastLoginTime = DateTime.UtcNow;
        IncrementVersion();
    }
    
    public void IncrementVersion()
    {
        ProfileVersion++;
    }
    
    public bool ValidateProfile()
    {
        return !string.IsNullOrEmpty(Username) && 
               !string.IsNullOrEmpty(Email) && 
               SecuritySettings?.IsValid() == true;
    }
}
```

#### 1.2 ç”¨æˆ·åå¥½å®ä½“

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Domain.Models/UserManagement/UserPreferences.cs`

```csharp
/// <summary>
/// ç”¨æˆ·åå¥½è®¾ç½®å®ä½“
/// </summary>
public class UserPreferences : IEntity
{
    public Guid PreferenceId { get; private set; }
    public Guid UserId { get; private set; }
    public string PreferenceCategory { get; private set; }
    public string PreferenceKey { get; private set; }
    public string PreferenceValue { get; private set; }
    public string ValueType { get; private set; }
    public DateTime LastUpdatedTime { get; private set; }
    public bool IsSystemDefault { get; private set; }
    public string Description { get; private set; }
    
    // å¯¼èˆªå±æ€§
    public virtual UserProfile User { get; private set; }
    
    private UserPreferences() { }
    
    public static UserPreferences Create(Guid userId, string category, string key, string value, string valueType = "String")
    {
        return new UserPreferences
        {
            PreferenceId = Guid.NewGuid(),
            UserId = userId,
            PreferenceCategory = category,
            PreferenceKey = key,
            PreferenceValue = value,
            ValueType = valueType,
            LastUpdatedTime = DateTime.UtcNow,
            IsSystemDefault = false
        };
    }
    
    public T GetTypedValue<T>()
    {
        return ValueType switch
        {
            "Boolean" => (T)(object)bool.Parse(PreferenceValue),
            "Integer" => (T)(object)int.Parse(PreferenceValue),
            "Double" => (T)(object)double.Parse(PreferenceValue),
            "DateTime" => (T)(object)DateTime.Parse(PreferenceValue),
            _ => (T)(object)PreferenceValue
        };
    }
    
    public void SetTypedValue<T>(T value)
    {
        PreferenceValue = value?.ToString();
        ValueType = typeof(T).Name;
        LastUpdatedTime = DateTime.UtcNow;
    }
}
```

#### 1.3 å®‰å…¨è®¾ç½®å€¼å¯¹è±¡

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Domain.Models/UserManagement/SecuritySettings.cs`

```csharp
/// <summary>
/// å®‰å…¨è®¾ç½®å€¼å¯¹è±¡
/// </summary>
public class SecuritySettings : ValueObject
{
    public string AuthenticationMethod { get; private set; }
    public int SessionTimeoutMinutes { get; private set; }
    public bool RequireTwoFactor { get; private set; }
    public DateTime PasswordLastChanged { get; private set; }
    public Dictionary<string, string> AdditionalSettings { get; private set; }
    
    private SecuritySettings() { }
    
    public static SecuritySettings CreateDefault()
    {
        return new SecuritySettings
        {
            AuthenticationMethod = "Windows",
            SessionTimeoutMinutes = 480, // 8å°æ—¶
            RequireTwoFactor = false,
            PasswordLastChanged = DateTime.UtcNow,
            AdditionalSettings = new Dictionary<string, string>()
        };
    }
    
    public static SecuritySettings Create(string authMethod, int timeoutMinutes, bool requireTwoFactor)
    {
        return new SecuritySettings
        {
            AuthenticationMethod = authMethod,
            SessionTimeoutMinutes = timeoutMinutes,
            RequireTwoFactor = requireTwoFactor,
            PasswordLastChanged = DateTime.UtcNow,
            AdditionalSettings = new Dictionary<string, string>()
        };
    }
    
    public bool IsValid()
    {
        return !string.IsNullOrEmpty(AuthenticationMethod) &&
               SessionTimeoutMinutes > 0 &&
               SessionTimeoutMinutes <= 1440; // æœ€å¤§24å°æ—¶
    }
    
    public bool RequiresPasswordChange()
    {
        return DateTime.UtcNow.Subtract(PasswordLastChanged).TotalDays > 90;
    }
    
    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return AuthenticationMethod;
        yield return SessionTimeoutMinutes;
        yield return RequireTwoFactor;
        yield return PasswordLastChanged;
    }
}
```

### 2. ä»»åŠ¡æ‰§è¡Œç›¸å…³å®ä½“

#### 2.1 ä»»åŠ¡æ‰§è¡Œå†å²èšåˆæ ¹

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Domain.Models/Execution/TaskExecutionHistory.cs`

```csharp
/// <summary>
/// ä»»åŠ¡æ‰§è¡Œå†å²èšåˆæ ¹
/// </summary>
public class TaskExecutionHistory : IAggregateRoot
{
    public Guid ExecutionId { get; private set; }
    public Guid UserId { get; private set; }
    public string RequestId { get; private set; }
    public string UserInput { get; private set; }
    public string RequestType { get; private set; }
    public ExecutionStatus ExecutionStatus { get; private set; }
    public DateTime StartTime { get; private set; }
    public DateTime? EndTime { get; private set; }
    public long TotalExecutionTime { get; private set; }
    public bool IsSuccessful { get; private set; }
    public string ResultSummary { get; private set; }
    public int ErrorCount { get; private set; }
    public string LlmProvider { get; private set; }
    public string LlmModel { get; private set; }
    public int TokenUsage { get; private set; }
    public decimal EstimatedCost { get; private set; }
    public List<string> Tags { get; private set; } = new();
    public Dictionary<string, object> Metadata { get; private set; } = new();
    
    // å¯¼èˆªå±æ€§
    public virtual UserProfile User { get; private set; }
    public virtual ICollection<ExecutionStepRecord> ExecutionSteps { get; private set; } = new List<ExecutionStepRecord>();
    public virtual ICollection<ErrorEventRecord> ErrorEvents { get; private set; } = new List<ErrorEventRecord>();
    public virtual ICollection<PerformanceMetricsRecord> PerformanceMetrics { get; private set; } = new List<PerformanceMetricsRecord>();
    
    private TaskExecutionHistory() { }
    
    public static TaskExecutionHistory Create(Guid userId, string userInput, string requestType)
    {
        return new TaskExecutionHistory
        {
            ExecutionId = Guid.NewGuid(),
            UserId = userId,
            RequestId = Guid.NewGuid().ToString("N")[..8],
            UserInput = userInput,
            RequestType = requestType,
            ExecutionStatus = ExecutionStatus.Pending,
            StartTime = DateTime.UtcNow
        };
    }
    
    public long CalculateExecutionTime()
    {
        if (EndTime.HasValue)
        {
            TotalExecutionTime = (long)(EndTime.Value - StartTime).TotalMilliseconds;
        }
        return TotalExecutionTime;
    }
    
    public void AddExecutionStep(ExecutionStepRecord step)
    {
        ExecutionSteps.Add(step);
    }
    
    public void MarkAsCompleted(bool isSuccessful)
    {
        EndTime = DateTime.UtcNow;
        IsSuccessful = isSuccessful;
        ExecutionStatus = isSuccessful ? ExecutionStatus.Completed : ExecutionStatus.Failed;
        CalculateExecutionTime();
    }
    
    public void AddErrorEvent(ErrorEventRecord errorEvent)
    {
        ErrorEvents.Add(errorEvent);
        ErrorCount++;
    }
}
```

#### 2.2 æ‰§è¡Œæ­¥éª¤è®°å½•å®ä½“

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Domain.Models/Execution/ExecutionStepRecord.cs`

```csharp
/// <summary>
/// æ‰§è¡Œæ­¥éª¤è®°å½•å®ä½“
/// </summary>
public class ExecutionStepRecord : IEntity
{
    public Guid StepRecordId { get; private set; }
    public Guid ExecutionId { get; private set; }
    public string StepId { get; private set; }
    public int StepOrder { get; private set; }
    public string StepDescription { get; private set; }
    public string AgentId { get; private set; }
    public string ActionName { get; private set; }
    public string Parameters { get; private set; }
    public ExecutionStatus StepStatus { get; private set; }
    public DateTime StartTime { get; private set; }
    public DateTime? EndTime { get; private set; }
    public long ExecutionTime { get; private set; }
    public bool IsSuccessful { get; private set; }
    public string OutputData { get; private set; }
    public string ErrorMessage { get; private set; }
    public int RetryCount { get; private set; }
    
    // å€¼å¯¹è±¡
    public ResourceUsage ResourceUsage { get; private set; }
    
    // å¯¼èˆªå±æ€§
    public virtual TaskExecutionHistory Execution { get; private set; }
    
    private ExecutionStepRecord() { }
    
    public static ExecutionStepRecord Create(Guid executionId, string stepId, int stepOrder, string agentId, string actionName)
    {
        return new ExecutionStepRecord
        {
            StepRecordId = Guid.NewGuid(),
            ExecutionId = executionId,
            StepId = stepId,
            StepOrder = stepOrder,
            AgentId = agentId,
            ActionName = actionName,
            StepStatus = ExecutionStatus.Pending,
            StartTime = DateTime.UtcNow,
            RetryCount = 0
        };
    }
    
    public long CalculateExecutionTime()
    {
        if (EndTime.HasValue)
        {
            ExecutionTime = (long)(EndTime.Value - StartTime).TotalMilliseconds;
        }
        return ExecutionTime;
    }
    
    public void IncrementRetryCount()
    {
        RetryCount++;
    }
    
    public void MarkAsCompleted(bool isSuccessful)
    {
        EndTime = DateTime.UtcNow;
        IsSuccessful = isSuccessful;
        StepStatus = isSuccessful ? ExecutionStatus.Completed : ExecutionStatus.Failed;
        CalculateExecutionTime();
    }
}
```

#### 2.3 æ‰§è¡ŒçŠ¶æ€æšä¸¾

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Domain.Models/Execution/ExecutionStatus.cs`

```csharp
/// <summary>
/// æ‰§è¡ŒçŠ¶æ€æšä¸¾
/// </summary>
public enum ExecutionStatus
{
    Pending = 0,
    Running = 1,
    Completed = 2,
    Failed = 3,
    Cancelled = 4,
    Timeout = 5
}
```

#### 2.4 èµ„æºä½¿ç”¨å€¼å¯¹è±¡

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Domain.Models/Execution/ResourceUsage.cs`

```csharp
/// <summary>
/// èµ„æºä½¿ç”¨å€¼å¯¹è±¡
/// </summary>
public class ResourceUsage : ValueObject
{
    public double CpuUsagePercent { get; private set; }
    public long MemoryUsageBytes { get; private set; }
    public long DiskIOBytes { get; private set; }
    public long NetworkIOBytes { get; private set; }
    public Dictionary<string, double> CustomMetrics { get; private set; }
    
    private ResourceUsage() { }
    
    public static ResourceUsage Create(double cpuUsage, long memoryUsage, long diskIO = 0, long networkIO = 0)
    {
        return new ResourceUsage
        {
            CpuUsagePercent = cpuUsage,
            MemoryUsageBytes = memoryUsage,
            DiskIOBytes = diskIO,
            NetworkIOBytes = networkIO,
            CustomMetrics = new Dictionary<string, double>()
        };
    }
    
    public bool IsWithinLimits(ResourceLimits limits)
    {
        return CpuUsagePercent <= limits.MaxCpuPercent &&
               MemoryUsageBytes <= limits.MaxMemoryBytes &&
               DiskIOBytes <= limits.MaxDiskIOBytes &&
               NetworkIOBytes <= limits.MaxNetworkIOBytes;
    }
    
    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return CpuUsagePercent;
        yield return MemoryUsageBytes;
        yield return DiskIOBytes;
        yield return NetworkIOBytes;
    }
}
```

## EF Coreé…ç½®è®¾è®¡

### 1. å®ä½“é…ç½®ç±»

#### 1.1 ç”¨æˆ·æ¡£æ¡ˆé…ç½®

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data/Configurations/UserProfileConfiguration.cs`

```csharp
/// <summary>
/// ç”¨æˆ·æ¡£æ¡ˆå®ä½“é…ç½®
/// </summary>
public class UserProfileConfiguration : IEntityTypeConfiguration<UserProfile>
{
    public void Configure(EntityTypeBuilder<UserProfile> builder)
    {
        // è¡¨åå’Œä¸»é”®
        builder.ToTable("UserProfiles");
        builder.HasKey(e => e.UserId);
        
        // å±æ€§é…ç½®
        builder.Property(e => e.UserId)
            .IsRequired()
            .HasDefaultValueSql("NEWID()");
            
        builder.Property(e => e.Username)
            .IsRequired()
            .HasMaxLength(100);
            
        builder.Property(e => e.Email)
            .IsRequired()
            .HasMaxLength(255);
            
        builder.Property(e => e.CreatedTime)
            .IsRequired()
            .HasDefaultValueSql("GETUTCDATE()");
            
        builder.Property(e => e.LastLoginTime)
            .IsRequired(false);
            
        builder.Property(e => e.IsActive)
            .IsRequired()
            .HasDefaultValue(true);
            
        builder.Property(e => e.ProfileVersion)
            .IsRequired()
            .HasDefaultValue(1);
        
        // å¤æ‚ç±»å‹é…ç½®
        builder.OwnsOne(e => e.SecuritySettings, securityBuilder =>
        {
            securityBuilder.Property(s => s.AuthenticationMethod)
                .HasMaxLength(50)
                .HasDefaultValue("Windows");
                
            securityBuilder.Property(s => s.SessionTimeoutMinutes)
                .HasDefaultValue(480);
                
            securityBuilder.Property(s => s.RequireTwoFactor)
                .HasDefaultValue(false);
                
            securityBuilder.Property(s => s.PasswordLastChanged)
                .IsRequired();
                
            securityBuilder.Property(s => s.AdditionalSettings)
                .HasConversion(
                    v => JsonSerializer.Serialize(v, JsonSerializerOptions.Default),
                    v => JsonSerializer.Deserialize<Dictionary<string, string>>(v, JsonSerializerOptions.Default))
                .HasColumnType("TEXT");
        });
        
        // JSONåˆ—é…ç½®
        builder.Property(e => e.Metadata)
            .HasConversion(
                v => JsonSerializer.Serialize(v, JsonSerializerOptions.Default),
                v => JsonSerializer.Deserialize<Dictionary<string, object>>(v, JsonSerializerOptions.Default))
            .HasColumnType("TEXT");
        
        // å…³ç³»é…ç½®
        builder.HasMany(e => e.UserPreferences)
            .WithOne(p => p.User)
            .HasForeignKey(p => p.UserId)
            .OnDelete(DeleteBehavior.Cascade);
            
        builder.HasMany(e => e.ExecutionHistories)
            .WithOne(h => h.User)
            .HasForeignKey(h => h.UserId)
            .OnDelete(DeleteBehavior.Cascade);
            
        builder.HasMany(e => e.WorkflowTemplates)
            .WithOne(w => w.User)
            .HasForeignKey(w => w.UserId)
            .OnDelete(DeleteBehavior.Cascade);
        
        // ç´¢å¼•é…ç½®
        builder.HasIndex(e => e.Username)
            .IsUnique()
            .HasDatabaseName("IX_UserProfiles_Username");
            
        builder.HasIndex(e => e.Email)
            .IsUnique()
            .HasDatabaseName("IX_UserProfiles_Email");
            
        builder.HasIndex(e => new { e.IsActive, e.CreatedTime })
            .HasDatabaseName("IX_UserProfiles_Active_Created");
    }
}
```

#### 1.2 ä»»åŠ¡æ‰§è¡Œå†å²é…ç½®

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data/Configurations/TaskExecutionHistoryConfiguration.cs`

```csharp
/// <summary>
/// ä»»åŠ¡æ‰§è¡Œå†å²å®ä½“é…ç½®
/// </summary>
public class TaskExecutionHistoryConfiguration : IEntityTypeConfiguration<TaskExecutionHistory>
{
    public void Configure(EntityTypeBuilder<TaskExecutionHistory> builder)
    {
        // è¡¨åå’Œä¸»é”®
        builder.ToTable("TaskExecutionHistory");
        builder.HasKey(e => e.ExecutionId);
        
        // å±æ€§é…ç½®
        builder.Property(e => e.ExecutionId)
            .IsRequired()
            .HasDefaultValueSql("NEWID()");
            
        builder.Property(e => e.UserId)
            .IsRequired();
            
        builder.Property(e => e.RequestId)
            .IsRequired()
            .HasMaxLength(50);
            
        builder.Property(e => e.UserInput)
            .HasMaxLength(4000);
            
        builder.Property(e => e.RequestType)
            .IsRequired()
            .HasMaxLength(100);
            
        builder.Property(e => e.ExecutionStatus)
            .IsRequired()
            .HasConversion<string>()
            .HasMaxLength(50);
            
        builder.Property(e => e.StartTime)
            .IsRequired();
            
        builder.Property(e => e.EndTime)
            .IsRequired(false);
            
        builder.Property(e => e.TotalExecutionTime)
            .HasDefaultValue(0);
            
        builder.Property(e => e.IsSuccessful)
            .HasDefaultValue(false);
            
        builder.Property(e => e.ResultSummary)
            .HasMaxLength(2000);
            
        builder.Property(e => e.ErrorCount)
            .HasDefaultValue(0);
            
        builder.Property(e => e.LlmProvider)
            .HasMaxLength(100);
            
        builder.Property(e => e.LlmModel)
            .HasMaxLength(100);
            
        builder.Property(e => e.TokenUsage)
            .HasDefaultValue(0);
            
        builder.Property(e => e.EstimatedCost)
            .HasColumnType("decimal(18,6)")
            .HasDefaultValue(0);
        
        // é›†åˆå±æ€§é…ç½®
        builder.Property(e => e.Tags)
            .HasConversion(
                v => JsonSerializer.Serialize(v, JsonSerializerOptions.Default),
                v => JsonSerializer.Deserialize<List<string>>(v, JsonSerializerOptions.Default))
            .HasColumnType("TEXT");
            
        builder.Property(e => e.Metadata)
            .HasConversion(
                v => JsonSerializer.Serialize(v, JsonSerializerOptions.Default),
                v => JsonSerializer.Deserialize<Dictionary<string, object>>(v, JsonSerializerOptions.Default))
            .HasColumnType("TEXT");
        
        // å…³ç³»é…ç½®
        builder.HasOne(e => e.User)
            .WithMany(u => u.ExecutionHistories)
            .HasForeignKey(e => e.UserId)
            .OnDelete(DeleteBehavior.Cascade);
            
        builder.HasMany(e => e.ExecutionSteps)
            .WithOne(s => s.Execution)
            .HasForeignKey(s => s.ExecutionId)
            .OnDelete(DeleteBehavior.Cascade);
        
        // ç´¢å¼•é…ç½®
        builder.HasIndex(e => new { e.UserId, e.StartTime })
            .HasDatabaseName("IX_TaskExecutionHistory_User_StartTime")
            .IsDescending(false, true); // UserIdå‡åºï¼ŒStartTimeé™åº
            
        builder.HasIndex(e => new { e.UserId, e.ExecutionStatus })
            .HasDatabaseName("IX_TaskExecutionHistory_User_Status");
            
        builder.HasIndex(e => e.RequestId)
            .HasDatabaseName("IX_TaskExecutionHistory_RequestId");
            
        builder.HasIndex(e => new { e.LlmProvider, e.LlmModel, e.StartTime })
            .HasDatabaseName("IX_TaskExecutionHistory_LLM_Time");
    }
}
```

#### 1.3 æ‰§è¡Œæ­¥éª¤è®°å½•é…ç½®

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data/Configurations/ExecutionStepRecordConfiguration.cs`

```csharp
/// <summary>
/// æ‰§è¡Œæ­¥éª¤è®°å½•å®ä½“é…ç½®
/// </summary>
public class ExecutionStepRecordConfiguration : IEntityTypeConfiguration<ExecutionStepRecord>
{
    public void Configure(EntityTypeBuilder<ExecutionStepRecord> builder)
    {
        // è¡¨åå’Œä¸»é”®
        builder.ToTable("ExecutionStepRecords");
        builder.HasKey(e => e.StepRecordId);
        
        // å±æ€§é…ç½®
        builder.Property(e => e.StepRecordId)
            .IsRequired()
            .HasDefaultValueSql("NEWID()");
            
        builder.Property(e => e.ExecutionId)
            .IsRequired();
            
        builder.Property(e => e.StepId)
            .IsRequired()
            .HasMaxLength(100);
            
        builder.Property(e => e.StepOrder)
            .IsRequired();
            
        builder.Property(e => e.StepDescription)
            .HasMaxLength(500);
            
        builder.Property(e => e.AgentId)
            .IsRequired()
            .HasMaxLength(100);
            
        builder.Property(e => e.ActionName)
            .IsRequired()
            .HasMaxLength(100);
            
        builder.Property(e => e.Parameters)
            .HasColumnType("TEXT");
            
        builder.Property(e => e.StepStatus)
            .IsRequired()
            .HasConversion<string>()
            .HasMaxLength(50);
            
        builder.Property(e => e.StartTime)
            .IsRequired();
            
        builder.Property(e => e.EndTime)
            .IsRequired(false);
            
        builder.Property(e => e.ExecutionTime)
            .HasDefaultValue(0);
            
        builder.Property(e => e.IsSuccessful)
            .HasDefaultValue(false);
            
        builder.Property(e => e.OutputData)
            .HasColumnType("TEXT");
            
        builder.Property(e => e.ErrorMessage)
            .HasMaxLength(2000);
            
        builder.Property(e => e.RetryCount)
            .HasDefaultValue(0);
        
        // å¤æ‚ç±»å‹é…ç½®
        builder.OwnsOne(e => e.ResourceUsage, resourceBuilder =>
        {
            resourceBuilder.Property(r => r.CpuUsagePercent)
                .HasColumnType("decimal(5,2)")
                .HasDefaultValue(0);
                
            resourceBuilder.Property(r => r.MemoryUsageBytes)
                .HasDefaultValue(0);
                
            resourceBuilder.Property(r => r.DiskIOBytes)
                .HasDefaultValue(0);
                
            resourceBuilder.Property(r => r.NetworkIOBytes)
                .HasDefaultValue(0);
                
            resourceBuilder.Property(r => r.CustomMetrics)
                .HasConversion(
                    v => JsonSerializer.Serialize(v, JsonSerializerOptions.Default),
                    v => JsonSerializer.Deserialize<Dictionary<string, double>>(v, JsonSerializerOptions.Default))
                .HasColumnType("TEXT");
        });
        
        // å…³ç³»é…ç½®
        builder.HasOne(e => e.Execution)
            .WithMany(h => h.ExecutionSteps)
            .HasForeignKey(e => e.ExecutionId)
            .OnDelete(DeleteBehavior.Cascade);
        
        // ç´¢å¼•é…ç½®
        builder.HasIndex(e => new { e.ExecutionId, e.StepOrder })
            .HasDatabaseName("IX_ExecutionStepRecords_Execution_Order")
            .IsUnique();
            
        builder.HasIndex(e => new { e.AgentId, e.ActionName, e.StartTime })
            .HasDatabaseName("IX_ExecutionStepRecords_Agent_Action_Time");
            
        builder.HasIndex(e => new { e.StepStatus, e.StartTime })
            .HasDatabaseName("IX_ExecutionStepRecords_Status_Time");
    }
}
```

### 2. æ•°æ®åº“è¿ç§»ç­–ç•¥

#### 2.1 è¿ç§»ç®¡ç†å™¨

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data.Sqlite/Migrations/DatabaseMigrator.cs`

```csharp
/// <summary>
/// æ•°æ®åº“è¿ç§»ç®¡ç†å™¨
/// </summary>
public class DatabaseMigrator : IDatabaseMigrator
{
    private readonly OpenAgenticAIDbContext _context;
    private readonly ILogger<DatabaseMigrator> _logger;
    
    public DatabaseMigrator(OpenAgenticAIDbContext context, ILogger<DatabaseMigrator> logger)
    {
        _context = context;
        _logger = logger;
    }
    
    public async Task<bool> NeedsMigrationAsync()
    {
        try
        {
            var pendingMigrations = await _context.Database.GetPendingMigrationsAsync();
            return pendingMigrations.Any();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "æ£€æŸ¥æ•°æ®åº“è¿ç§»çŠ¶æ€æ—¶å‘ç”Ÿé”™è¯¯");
            return true; // å®‰å…¨èµ·è§ï¼Œå‡è®¾éœ€è¦è¿ç§»
        }
    }
    
    public async Task<string> GetCurrentVersionAsync()
    {
        try
        {
            var appliedMigrations = await _context.Database.GetAppliedMigrationsAsync();
            return appliedMigrations.LastOrDefault() ?? "Initial";
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "è·å–å½“å‰æ•°æ®åº“ç‰ˆæœ¬æ—¶å‘ç”Ÿé”™è¯¯");
            return "Unknown";
        }
    }
    
    public async Task MigrateToLatestAsync()
    {
        try
        {
            _logger.LogInformation("å¼€å§‹æ•°æ®åº“è¿ç§»åˆ°æœ€æ–°ç‰ˆæœ¬");
            
            // ç¡®ä¿æ•°æ®åº“å­˜åœ¨
            await _context.Database.EnsureCreatedAsync();
            
            // æ‰§è¡Œå¾…å¤„ç†çš„è¿ç§»
            await _context.Database.MigrateAsync();
            
            // éªŒè¯è¿ç§»ç»“æœ
            var currentVersion = await GetCurrentVersionAsync();
            _logger.LogInformation("æ•°æ®åº“è¿ç§»å®Œæˆï¼Œå½“å‰ç‰ˆæœ¬: {Version}", currentVersion);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "æ•°æ®åº“è¿ç§»å¤±è´¥");
            throw new DatabaseMigrationException("æ•°æ®åº“è¿ç§»å¤±è´¥", ex);
        }
    }
    
    public async Task MigrateToVersionAsync(string targetVersion)
    {
        try
        {
            _logger.LogInformation("å¼€å§‹æ•°æ®åº“è¿ç§»åˆ°æŒ‡å®šç‰ˆæœ¬: {TargetVersion}", targetVersion);
            
            // è·å–æ‰€æœ‰å¯ç”¨è¿ç§»
            var allMigrations = _context.Database.GetMigrations().ToList();
            var targetMigration = allMigrations.FirstOrDefault(m => m.Contains(targetVersion));
            
            if (targetMigration == null)
            {
                throw new ArgumentException($"æœªæ‰¾åˆ°ç›®æ ‡ç‰ˆæœ¬çš„è¿ç§»: {targetVersion}");
            }
            
            // è¿ç§»åˆ°æŒ‡å®šç‰ˆæœ¬
            await _context.Database.MigrateAsync(targetMigration);
            
            _logger.LogInformation("æ•°æ®åº“è¿ç§»åˆ°ç‰ˆæœ¬ {TargetVersion} å®Œæˆ", targetVersion);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "æ•°æ®åº“è¿ç§»åˆ°ç‰ˆæœ¬ {TargetVersion} å¤±è´¥", targetVersion);
            throw new DatabaseMigrationException($"æ•°æ®åº“è¿ç§»åˆ°ç‰ˆæœ¬ {targetVersion} å¤±è´¥", ex);
        }
    }
    
    public async Task<IEnumerable<string>> GetAvailableVersionsAsync()
    {
        try
        {
            var migrations = _context.Database.GetMigrations();
            return migrations.Select(m => ExtractVersionFromMigrationName(m)).ToList();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "è·å–å¯ç”¨æ•°æ®åº“ç‰ˆæœ¬æ—¶å‘ç”Ÿé”™è¯¯");
            return Enumerable.Empty<string>();
        }
    }
    
    private string ExtractVersionFromMigrationName(string migrationName)
    {
        // ä»è¿ç§»åç§°ä¸­æå–ç‰ˆæœ¬ä¿¡æ¯
        // ä¾‹å¦‚: "20250724120000_InitialCreate" -> "v1.0.0"
        var timestamp = migrationName.Split('_')[0];
        return $"v1.0.{timestamp[..8]}"; // ç®€åŒ–ç‰ˆæœ¬å·
    }
}
```

### 3. ç´¢å¼•ä¼˜åŒ–ç­–ç•¥

#### 3.1 æ™ºèƒ½ç´¢å¼•ç®¡ç†å™¨

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data/Optimization/IndexOptimizer.cs`

```csharp
/// <summary>
/// æ™ºèƒ½ç´¢å¼•ä¼˜åŒ–å™¨
/// </summary>
public class IndexOptimizer : IIndexOptimizer
{
    private readonly OpenAgenticAIDbContext _context;
    private readonly ILogger<IndexOptimizer> _logger;
    
    public IndexOptimizer(OpenAgenticAIDbContext context, ILogger<IndexOptimizer> logger)
    {
        _context = context;
        _logger = logger;
    }
    
    public async Task OptimizeIndexesAsync()
    {
        try
        {
            _logger.LogInformation("å¼€å§‹ç´¢å¼•ä¼˜åŒ–");
            
            // 1. åˆ†ææŸ¥è¯¢æ¨¡å¼
            var queryPatterns = await AnalyzeQueryPatternsAsync();
            
            // 2. è¯†åˆ«ç¼ºå¤±ç´¢å¼•
            var missingIndexes = await IdentifyMissingIndexesAsync(queryPatterns);
            
            // 3. åˆ›å»ºæ¨èç´¢å¼•
            foreach (var index in missingIndexes)
            {
                await CreateIndexAsync(index);
            }
            
            // 4. æ¸…ç†æ— ç”¨ç´¢å¼•
            var unusedIndexes = await IdentifyUnusedIndexesAsync();
            foreach (var index in unusedIndexes)
            {
                await DropIndexAsync(index);
            }
            
            // 5. æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            await UpdateStatisticsAsync();
            
            _logger.LogInformation("ç´¢å¼•ä¼˜åŒ–å®Œæˆ");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ç´¢å¼•ä¼˜åŒ–å¤±è´¥");
            throw;
        }
    }
    
    private async Task<List<QueryPattern>> AnalyzeQueryPatternsAsync()
    {
        // åˆ†ææœ€è¿‘çš„æŸ¥è¯¢æ¨¡å¼
        var patterns = new List<QueryPattern>();
        
        // ä»æŸ¥è¯¢æ—¥å¿—ä¸­åˆ†æå¸¸è§æŸ¥è¯¢æ¨¡å¼
        // è¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥åˆ†æSQLæŸ¥è¯¢æ—¥å¿—
        patterns.Add(new QueryPattern
        {
            TableName = "TaskExecutionHistory",
            Columns = new[] { "UserId", "StartTime" },
            QueryType = QueryType.Select,
            Frequency = 1000
        });
        
        patterns.Add(new QueryPattern
        {
            TableName = "ExecutionStepRecords",
            Columns = new[] { "ExecutionId", "StepOrder" },
            QueryType = QueryType.Select,
            Frequency = 800
        });
        
        return patterns;
    }
    
    private async Task<List<IndexRecommendation>> IdentifyMissingIndexesAsync(List<QueryPattern> queryPatterns)
    {
        var recommendations = new List<IndexRecommendation>();
        
        foreach (var pattern in queryPatterns.Where(p => p.Frequency > 100))
        {
            var indexName = $"IX_{pattern.TableName}_{string.Join("_", pattern.Columns)}";
            var exists = await IndexExistsAsync(pattern.TableName, indexName);
            
            if (!exists)
            {
                recommendations.Add(new IndexRecommendation
                {
                    TableName = pattern.TableName,
                    IndexName = indexName,
                    Columns = pattern.Columns,
                    Priority = CalculateIndexPriority(pattern)
                });
            }
        }
        
        return recommendations.OrderByDescending(r => r.Priority).ToList();
    }
    
    private async Task CreateIndexAsync(IndexRecommendation recommendation)
    {
        try
        {
            var sql = $"CREATE INDEX {recommendation.IndexName} ON {recommendation.TableName} ({string.Join(", ", recommendation.Columns)})";
            await _context.Database.ExecuteSqlRawAsync(sql);
            
            _logger.LogInformation("åˆ›å»ºç´¢å¼•: {IndexName}", recommendation.IndexName);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "åˆ›å»ºç´¢å¼•å¤±è´¥: {IndexName}", recommendation.IndexName);
        }
    }
    
    private int CalculateIndexPriority(QueryPattern pattern)
    {
        // æ ¹æ®æŸ¥è¯¢é¢‘ç‡ã€è¡¨å¤§å°ç­‰å› ç´ è®¡ç®—ç´¢å¼•ä¼˜å…ˆçº§
        return pattern.Frequency * pattern.Columns.Length;
    }
}
```

## ä»“å‚¨æ¨¡å¼å®ç°

### 1. åŸºç¡€ä»“å‚¨æ¥å£

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Shared.Contracts/Repositories/IRepository.cs`

```csharp
/// <summary>
/// åŸºç¡€ä»“å‚¨æ¥å£
/// </summary>
public interface IRepository<T> where T : class, IAggregateRoot
{
    Task<T> GetByIdAsync(object id, CancellationToken cancellationToken = default);
    Task<IReadOnlyList<T>> GetAllAsync(CancellationToken cancellationToken = default);
    Task<IReadOnlyList<T>> FindAsync(ISpecification<T> specification, CancellationToken cancellationToken = default);
    Task<T> FirstOrDefaultAsync(ISpecification<T> specification, CancellationToken cancellationToken = default);
    Task<int> CountAsync(ISpecification<T> specification, CancellationToken cancellationToken = default);
    Task<T> AddAsync(T entity, CancellationToken cancellationToken = default);
    Task UpdateAsync(T entity, CancellationToken cancellationToken = default);
    Task DeleteAsync(T entity, CancellationToken cancellationToken = default);
    Task<PagedResult<T>> GetPagedAsync(ISpecification<T> specification, int pageNumber, int pageSize, CancellationToken cancellationToken = default);
}
```

### 2. ä¸“é—¨ä»“å‚¨æ¥å£

#### 2.1 ç”¨æˆ·ç®¡ç†ä»“å‚¨æ¥å£

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Shared.Contracts/Repositories/IUserProfileRepository.cs`

```csharp
/// <summary>
/// ç”¨æˆ·æ¡£æ¡ˆä»“å‚¨æ¥å£
/// </summary>
public interface IUserProfileRepository : IRepository<UserProfile>
{
    Task<UserProfile> GetByUsernameAsync(string username, CancellationToken cancellationToken = default);
    Task<UserProfile> GetByEmailAsync(string email, CancellationToken cancellationToken = default);
    Task<IReadOnlyList<UserPreferences>> GetUserPreferencesAsync(Guid userId, CancellationToken cancellationToken = default);
    Task UpdateUserPreferencesAsync(Guid userId, Dictionary<string, object> preferences, CancellationToken cancellationToken = default);
    Task<IReadOnlyList<UserProfile>> GetUsersByRoleAsync(string role, CancellationToken cancellationToken = default);
    Task UpdateLastLoginAsync(Guid userId, DateTime loginTime, CancellationToken cancellationToken = default);
    Task IncrementLoginCountAsync(Guid userId, CancellationToken cancellationToken = default);
    Task<PagedResult<UserProfile>> SearchUsersAsync(string searchTerm, int pageNumber, int pageSize, CancellationToken cancellationToken = default);
    Task<IReadOnlyList<UserProfile>> GetActiveUsersAsync(DateTime since, CancellationToken cancellationToken = default);
    Task BulkUpdateSecuritySettingsAsync(List<Guid> userIds, SecuritySettings settings, CancellationToken cancellationToken = default);
}
```

#### 2.2 ä»»åŠ¡æ‰§è¡Œå†å²ä»“å‚¨æ¥å£

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Shared.Contracts/Repositories/ITaskExecutionHistoryRepository.cs`

```csharp
/// <summary>
/// ä»»åŠ¡æ‰§è¡Œå†å²ä»“å‚¨æ¥å£
/// </summary>
public interface ITaskExecutionHistoryRepository : IRepository<TaskExecutionHistory>
{
    Task<IReadOnlyList<TaskExecutionHistory>> GetByUserIdAsync(Guid userId, int limit = 100, CancellationToken cancellationToken = default);
    Task<IReadOnlyList<TaskExecutionHistory>> GetByStatusAsync(ExecutionStatus status, CancellationToken cancellationToken = default);
    Task<IReadOnlyList<TaskExecutionHistory>> GetByDateRangeAsync(DateTime startDate, DateTime endDate, CancellationToken cancellationToken = default);
    Task<TaskExecutionStatistics> GetExecutionStatisticsAsync(Guid userId, DateTime from, DateTime to, CancellationToken cancellationToken = default);
    Task<IReadOnlyList<TaskExecutionHistory>> SearchByInputAsync(string searchTerm, Guid? userId = null, CancellationToken cancellationToken = default);
    Task<IReadOnlyList<ExecutionStepRecord>> GetExecutionStepsAsync(Guid executionId, CancellationToken cancellationToken = default);
    Task ArchiveOldExecutionsAsync(DateTime cutoffDate, CancellationToken cancellationToken = default);
    Task<decimal> CalculateTotalCostAsync(Guid userId, DateTime from, DateTime to, CancellationToken cancellationToken = default);
    Task<IReadOnlyList<TaskExecutionHistory>> GetFailedExecutionsAsync(Guid userId, int limit = 50, CancellationToken cancellationToken = default);
    Task BulkDeleteAsync(IEnumerable<Guid> executionIds, CancellationToken cancellationToken = default);
}
```

### 3. åŸºç¡€ä»“å‚¨å®ç°

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data.Repositories/RepositoryBase.cs`

```csharp
/// <summary>
/// åŸºç¡€ä»“å‚¨å®ç°
/// </summary>
public abstract class RepositoryBase<T> : IRepository<T> where T : class, IAggregateRoot
{
    protected readonly OpenAgenticAIDbContext _context;
    protected readonly ILogger<RepositoryBase<T>> _logger;
    protected readonly DbSet<T> _dbSet;

    protected RepositoryBase(OpenAgenticAIDbContext context, ILogger<RepositoryBase<T>> logger)
    {
        _context = context ?? throw new ArgumentNullException(nameof(context));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _dbSet = context.Set<T>();
    }

    public virtual async Task<T> GetByIdAsync(object id, CancellationToken cancellationToken = default)
    {
        return await _dbSet.FindAsync(new object[] { id }, cancellationToken);
    }

    public virtual async Task<IReadOnlyList<T>> GetAllAsync(CancellationToken cancellationToken = default)
    {
        return await _dbSet.ToListAsync(cancellationToken);
    }

    public virtual async Task<IReadOnlyList<T>> FindAsync(ISpecification<T> specification, CancellationToken cancellationToken = default)
    {
        return await ApplySpecification(specification).ToListAsync(cancellationToken);
    }

    public virtual async Task<T> FirstOrDefaultAsync(ISpecification<T> specification, CancellationToken cancellationToken = default)
    {
        return await ApplySpecification(specification).FirstOrDefaultAsync(cancellationToken);
    }

    public virtual async Task<int> CountAsync(ISpecification<T> specification, CancellationToken cancellationToken = default)
    {
        return await ApplySpecification(specification).CountAsync(cancellationToken);
    }

    public virtual async Task<T> AddAsync(T entity, CancellationToken cancellationToken = default)
    {
        var entry = await _dbSet.AddAsync(entity, cancellationToken);
        return entry.Entity;
    }

    public virtual Task UpdateAsync(T entity, CancellationToken cancellationToken = default)
    {
        _dbSet.Update(entity);
        return Task.CompletedTask;
    }

    public virtual Task DeleteAsync(T entity, CancellationToken cancellationToken = default)
    {
        _dbSet.Remove(entity);
        return Task.CompletedTask;
    }

    public virtual async Task<PagedResult<T>> GetPagedAsync(
        ISpecification<T> specification,
        int pageNumber,
        int pageSize,
        CancellationToken cancellationToken = default)
    {
        var query = ApplySpecification(specification);
        var totalCount = await query.CountAsync(cancellationToken);
        
        var items = await query
            .Skip((pageNumber - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync(cancellationToken);
            
        return new PagedResult<T>(items, totalCount, pageNumber, pageSize);
    }

    protected virtual IQueryable<T> ApplySpecification(ISpecification<T> specification)
    {
        return SpecificationEvaluator.GetQuery(_dbSet.AsQueryable(), specification);
    }
}
```

### 4. å…·ä½“ä»“å‚¨å®ç°

#### 4.1 ç”¨æˆ·æ¡£æ¡ˆä»“å‚¨å®ç°

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data.Repositories/UserProfileRepository.cs`

```csharp
/// <summary>
/// ç”¨æˆ·æ¡£æ¡ˆä»“å‚¨å®ç°
/// </summary>
public class UserProfileRepository : RepositoryBase<UserProfile>, IUserProfileRepository
{
    public UserProfileRepository(OpenAgenticAIDbContext context, ILogger<UserProfileRepository> logger)
        : base(context, logger) { }

    public async Task<UserProfile> GetByUsernameAsync(string username, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .Include(u => u.UserPreferences)
            .FirstOrDefaultAsync(u => u.Username == username, cancellationToken);
    }

    public async Task<UserProfile> GetByEmailAsync(string email, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .Include(u => u.UserPreferences)
            .FirstOrDefaultAsync(u => u.Email == email, cancellationToken);
    }

    public async Task<IReadOnlyList<UserPreferences>> GetUserPreferencesAsync(Guid userId, CancellationToken cancellationToken = default)
    {
        return await _context.Set<UserPreferences>()
            .Where(p => p.UserId == userId)
            .OrderBy(p => p.PreferenceCategory)
            .ThenBy(p => p.PreferenceKey)
            .ToListAsync(cancellationToken);
    }

    public async Task UpdateUserPreferencesAsync(Guid userId, Dictionary<string, object> preferences, CancellationToken cancellationToken = default)
    {
        var existingPreferences = await _context.Set<UserPreferences>()
            .Where(p => p.UserId == userId)
            .ToListAsync(cancellationToken);

        foreach (var kvp in preferences)
        {
            var parts = kvp.Key.Split('.');
            if (parts.Length != 2) continue;

            var category = parts[0];
            var key = parts[1];

            var existing = existingPreferences.FirstOrDefault(p => 
                p.PreferenceCategory == category && p.PreferenceKey == key);

            if (existing != null)
            {
                existing.SetTypedValue(kvp.Value);
            }
            else
            {
                var newPreference = UserPreferences.Create(userId, category, key, kvp.Value?.ToString());
                await _context.Set<UserPreferences>().AddAsync(newPreference, cancellationToken);
            }
        }
    }

    public async Task<IReadOnlyList<UserProfile>> GetUsersByRoleAsync(string role, CancellationToken cancellationToken = default)
    {
        // è¿™é‡Œå‡è®¾è§’è‰²ä¿¡æ¯å­˜å‚¨åœ¨Metadataä¸­
        return await _dbSet
            .Where(u => u.Metadata.ContainsKey("Role") && u.Metadata["Role"].ToString() == role)
            .ToListAsync(cancellationToken);
    }

    public async Task UpdateLastLoginAsync(Guid userId, DateTime loginTime, CancellationToken cancellationToken = default)
    {
        var user = await GetByIdAsync(userId, cancellationToken);
        if (user != null)
        {
            user.UpdateLastLogin();
            await UpdateAsync(user, cancellationToken);
        }
    }

    public async Task IncrementLoginCountAsync(Guid userId, CancellationToken cancellationToken = default)
    {
        // ä½¿ç”¨åŸå§‹SQLæé«˜æ€§èƒ½
        await _context.Database.ExecuteSqlRawAsync(
            "UPDATE UserProfiles SET LoginCount = LoginCount + 1 WHERE UserId = {0}",
            userId);
    }

    public async Task<PagedResult<UserProfile>> SearchUsersAsync(string searchTerm, int pageNumber, int pageSize, CancellationToken cancellationToken = default)
    {
        var query = _dbSet.AsQueryable();

        if (!string.IsNullOrEmpty(searchTerm))
        {
            query = query.Where(u => 
                u.Username.Contains(searchTerm) || 
                u.Email.Contains(searchTerm));
        }

        var totalCount = await query.CountAsync(cancellationToken);
        var items = await query
            .OrderBy(u => u.Username)
            .Skip((pageNumber - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync(cancellationToken);

        return new PagedResult<UserProfile>(items, totalCount, pageNumber, pageSize);
    }

    public async Task<IReadOnlyList<UserProfile>> GetActiveUsersAsync(DateTime since, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .Where(u => u.IsActive && u.LastLoginTime >= since)
            .OrderByDescending(u => u.LastLoginTime)
            .ToListAsync(cancellationToken);
    }

    public async Task BulkUpdateSecuritySettingsAsync(List<Guid> userIds, SecuritySettings settings, CancellationToken cancellationToken = default)
    {
        var users = await _dbSet
            .Where(u => userIds.Contains(u.UserId))
            .ToListAsync(cancellationToken);

        foreach (var user in users)
        {
            // è¿™é‡Œéœ€è¦å®ç°SecuritySettingsçš„æ›´æ–°é€»è¾‘
            // ç”±äºSecuritySettingsæ˜¯å€¼å¯¹è±¡ï¼Œéœ€è¦åˆ›å»ºæ–°å®ä¾‹
            user.IncrementVersion();
        }

        _context.UpdateRange(users);
    }
}
```

### 5. å·¥ä½œå•å…ƒæ¨¡å¼

#### 5.1 å·¥ä½œå•å…ƒæ¥å£

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Shared.Contracts/IUnitOfWork.cs`

```csharp
/// <summary>
/// å·¥ä½œå•å…ƒæ¥å£
/// </summary>
public interface IUnitOfWork : IDisposable
{
    // ä»“å‚¨å±æ€§
    IUserProfileRepository Users { get; }
    ITaskExecutionHistoryRepository TaskExecutions { get; }
    IWorkflowTemplateRepository WorkflowTemplates { get; }
    IModelProviderRepository ModelProviders { get; }
    IModelRepository Models { get; }
    IMCPConfigurationRepository MCPConfigurations { get; }
    IAgentCapabilityRepository AgentCapabilities { get; }
    
    // äº‹åŠ¡ç®¡ç†
    Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);
    Task BeginTransactionAsync(CancellationToken cancellationToken = default);
    Task CommitTransactionAsync(CancellationToken cancellationToken = default);
    Task RollbackTransactionAsync(CancellationToken cancellationToken = default);
    
    // æ‰¹é‡æ“ä½œ
    Task<int> ExecuteSqlRawAsync(string sql, params object[] parameters);
    Task<int> ExecuteSqlRawAsync(string sql, CancellationToken cancellationToken, params object[] parameters);
}
```

#### 5.2 å·¥ä½œå•å…ƒå®ç°

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data.Repositories/UnitOfWork.cs`

```csharp
/// <summary>
/// å·¥ä½œå•å…ƒå®ç°
/// </summary>
public class UnitOfWork : IUnitOfWork
{
    private readonly OpenAgenticAIDbContext _context;
    private readonly ILogger<UnitOfWork> _logger;
    private IDbContextTransaction _transaction;
    
    // ä»“å‚¨å®ä¾‹
    private IUserProfileRepository _users;
    private ITaskExecutionHistoryRepository _taskExecutions;
    private IWorkflowTemplateRepository _workflowTemplates;
    private IModelProviderRepository _modelProviders;
    private IModelRepository _models;
    private IMCPConfigurationRepository _mcpConfigurations;
    private IAgentCapabilityRepository _agentCapabilities;

    public UnitOfWork(
        OpenAgenticAIDbContext context,
        ILogger<UnitOfWork> logger,
        IServiceProvider serviceProvider)
    {
        _context = context ?? throw new ArgumentNullException(nameof(context));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _serviceProvider = serviceProvider;
    }

    // ä»“å‚¨å±æ€§ - å»¶è¿Ÿåˆå§‹åŒ–
    public IUserProfileRepository Users => 
        _users ??= _serviceProvider.GetRequiredService<IUserProfileRepository>();
        
    public ITaskExecutionHistoryRepository TaskExecutions => 
        _taskExecutions ??= _serviceProvider.GetRequiredService<ITaskExecutionHistoryRepository>();
        
    public IWorkflowTemplateRepository WorkflowTemplates => 
        _workflowTemplates ??= _serviceProvider.GetRequiredService<IWorkflowTemplateRepository>();
        
    public IModelProviderRepository ModelProviders => 
        _modelProviders ??= _serviceProvider.GetRequiredService<IModelProviderRepository>();
        
    public IModelRepository Models => 
        _models ??= _serviceProvider.GetRequiredService<IModelRepository>();
        
    public IMCPConfigurationRepository MCPConfigurations => 
        _mcpConfigurations ??= _serviceProvider.GetRequiredService<IMCPConfigurationRepository>();
        
    public IAgentCapabilityRepository AgentCapabilities => 
        _agentCapabilities ??= _serviceProvider.GetRequiredService<IAgentCapabilityRepository>();

    public async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            var result = await _context.SaveChangesAsync(cancellationToken);
            _logger.LogDebug("ä¿å­˜äº† {ChangeCount} ä¸ªæ•°æ®åº“æ›´æ”¹", result);
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ä¿å­˜æ•°æ®åº“æ›´æ”¹æ—¶å‘ç”Ÿé”™è¯¯");
            throw;
        }
    }

    public async Task BeginTransactionAsync(CancellationToken cancellationToken = default)
    {
        if (_transaction != null)
        {
            throw new InvalidOperationException("äº‹åŠ¡å·²ç»å¼€å§‹");
        }

        _transaction = await _context.Database.BeginTransactionAsync(cancellationToken);
        _logger.LogDebug("å¼€å§‹æ•°æ®åº“äº‹åŠ¡");
    }

    public async Task CommitTransactionAsync(CancellationToken cancellationToken = default)
    {
        if (_transaction == null)
        {
            throw new InvalidOperationException("æ²¡æœ‰æ´»åŠ¨çš„äº‹åŠ¡");
        }

        try
        {
            await _transaction.CommitAsync(cancellationToken);
            _logger.LogDebug("æäº¤æ•°æ®åº“äº‹åŠ¡");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "æäº¤äº‹åŠ¡æ—¶å‘ç”Ÿé”™è¯¯");
            await RollbackTransactionAsync(cancellationToken);
            throw;
        }
        finally
        {
            await _transaction.DisposeAsync();
            _transaction = null;
        }
    }

    public async Task RollbackTransactionAsync(CancellationToken cancellationToken = default)
    {
        if (_transaction == null)
        {
            return;
        }

        try
        {
            await _transaction.RollbackAsync(cancellationToken);
            _logger.LogDebug("å›æ»šæ•°æ®åº“äº‹åŠ¡");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "å›æ»šäº‹åŠ¡æ—¶å‘ç”Ÿé”™è¯¯");
        }
        finally
        {
            await _transaction.DisposeAsync();
            _transaction = null;
        }
    }

    public async Task<int> ExecuteSqlRawAsync(string sql, params object[] parameters)
    {
        return await _context.Database.ExecuteSqlRawAsync(sql, parameters);
    }

    public async Task<int> ExecuteSqlRawAsync(string sql, CancellationToken cancellationToken, params object[] parameters)
    {
        return await _context.Database.ExecuteSqlRawAsync(sql, cancellationToken, parameters);
    }

    public void Dispose()
    {
        _transaction?.Dispose();
        _context?.Dispose();
    }
}
```

## æŸ¥è¯¢è§„çº¦æ¨¡å¼

### 1. è§„çº¦åŸºç±»

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data.Specifications/BaseSpecification.cs`

```csharp
/// <summary>
/// åŸºç¡€è§„çº¦å®ç°
/// </summary>
public abstract class BaseSpecification<T> : ISpecification<T>
{
    public Expression<Func<T, bool>> Criteria { get; private set; }
    public List<Expression<Func<T, object>>> Includes { get; } = new();
    public List<string> IncludeStrings { get; } = new();
    public Expression<Func<T, object>> OrderBy { get; private set; }
    public Expression<Func<T, object>> OrderByDescending { get; private set; }
    public List<Expression<Func<T, object>>> ThenBy { get; } = new();
    public List<Expression<Func<T, object>>> ThenByDescending { get; } = new();
    public int Take { get; private set; }
    public int Skip { get; private set; }
    public bool IsPagingEnabled { get; private set; }

    protected BaseSpecification(Expression<Func<T, bool>> criteria = null)
    {
        Criteria = criteria;
    }

    protected virtual void AddInclude(Expression<Func<T, object>> includeExpression)
    {
        Includes.Add(includeExpression);
    }

    protected virtual void AddInclude(string includeString)
    {
        IncludeStrings.Add(includeString);
    }

    protected virtual void ApplyPaging(int skip, int take)
    {
        Skip = skip;
        Take = take;
        IsPagingEnabled = true;
    }

    protected virtual void ApplyOrderBy(Expression<Func<T, object>> orderByExpression)
    {
        OrderBy = orderByExpression;
    }

    protected virtual void ApplyOrderByDescending(Expression<Func<T, object>> orderByDescendingExpression)
    {
        OrderByDescending = orderByDescendingExpression;
    }

    protected virtual void ApplyThenBy(Expression<Func<T, object>> thenByExpression)
    {
        ThenBy.Add(thenByExpression);
    }

    protected virtual void ApplyThenByDescending(Expression<Func<T, object>> thenByDescendingExpression)
    {
        ThenByDescending.Add(thenByDescendingExpression);
    }
}
```

### 2. ç”¨æˆ·ç›¸å…³è§„çº¦

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data.Specifications/Users/UserSpecifications.cs`

```csharp
/// <summary>
/// æ ¹æ®ç”¨æˆ·åæŸ¥è¯¢ç”¨æˆ·è§„çº¦
/// </summary>
public class UserByUsernameSpecification : BaseSpecification<UserProfile>
{
    public UserByUsernameSpecification(string username) 
        : base(u => u.Username == username)
    {
        AddInclude(u => u.UserPreferences);
        AddInclude(u => u.ExecutionHistories.OrderByDescending(h => h.StartTime).Take(10));
    }
}

/// <summary>
/// æ´»è·ƒç”¨æˆ·è§„çº¦
/// </summary>
public class ActiveUsersSpecification : BaseSpecification<UserProfile>
{
    public ActiveUsersSpecification(DateTime since) 
        : base(u => u.IsActive && u.LastLoginTime >= since)
    {
        ApplyOrderByDescending(u => u.LastLoginTime);
    }
}

/// <summary>
/// ç”¨æˆ·æœç´¢è§„çº¦
/// </summary>
public class UserSearchSpecification : BaseSpecification<UserProfile>
{
    public UserSearchSpecification(string searchTerm, bool includeInactive = false) 
        : base(BuildCriteria(searchTerm, includeInactive))
    {
        ApplyOrderBy(u => u.Username);
    }

    private static Expression<Func<UserProfile, bool>> BuildCriteria(string searchTerm, bool includeInactive)
    {
        var predicate = PredicateBuilder.New<UserProfile>(true);

        if (!includeInactive)
        {
            predicate = predicate.And(u => u.IsActive);
        }

        if (!string.IsNullOrEmpty(searchTerm))
        {
            predicate = predicate.And(u => 
                u.Username.Contains(searchTerm) || 
                u.Email.Contains(searchTerm));
        }

        return predicate;
    }
}
```

### 3. ä»»åŠ¡æ‰§è¡Œç›¸å…³è§„çº¦

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data.Specifications/Execution/TaskExecutionSpecifications.cs`

```csharp
/// <summary>
/// ç”¨æˆ·ä»»åŠ¡æ‰§è¡Œå†å²è§„çº¦
/// </summary>
public class UserTaskExecutionHistorySpecification : BaseSpecification<TaskExecutionHistory>
{
    public UserTaskExecutionHistorySpecification(Guid userId, int limit = 100) 
        : base(t => t.UserId == userId)
    {
        AddInclude(t => t.ExecutionSteps);
        ApplyOrderByDescending(t => t.StartTime);
        ApplyPaging(0, limit);
    }
}

/// <summary>
/// å¤±è´¥ä»»åŠ¡æ‰§è¡Œè§„çº¦
/// </summary>
public class FailedTaskExecutionsSpecification : BaseSpecification<TaskExecutionHistory>
{
    public FailedTaskExecutionsSpecification(Guid? userId = null, DateTime? since = null) 
        : base(BuildCriteria(userId, since))
    {
        AddInclude(t => t.ExecutionSteps);
        AddInclude(t => t.ErrorEvents);
        ApplyOrderByDescending(t => t.StartTime);
    }

    private static Expression<Func<TaskExecutionHistory, bool>> BuildCriteria(Guid? userId, DateTime? since)
    {
        var predicate = PredicateBuilder.New<TaskExecutionHistory>(t => 
            t.ExecutionStatus == ExecutionStatus.Failed || !t.IsSuccessful);

        if (userId.HasValue)
        {
            predicate = predicate.And(t => t.UserId == userId.Value);
        }

        if (since.HasValue)
        {
            predicate = predicate.And(t => t.StartTime >= since.Value);
        }

        return predicate;
    }
}

/// <summary>
/// ä»»åŠ¡æ‰§è¡Œç»Ÿè®¡è§„çº¦
/// </summary>
public class TaskExecutionStatisticsSpecification : BaseSpecification<TaskExecutionHistory>
{
    public TaskExecutionStatisticsSpecification(Guid userId, DateTime from, DateTime to) 
        : base(t => t.UserId == userId && t.StartTime >= from && t.StartTime <= to)
    {
        // ä¸éœ€è¦åŒ…å«å¯¼èˆªå±æ€§ï¼Œåªéœ€è¦ç»Ÿè®¡æ•°æ®
    }
}

/// <summary>
/// ä»»åŠ¡æœç´¢è§„çº¦
/// </summary>
public class TaskSearchSpecification : BaseSpecification<TaskExecutionHistory>
{
    public TaskSearchSpecification(string searchTerm, Guid? userId = null) 
        : base(BuildSearchCriteria(searchTerm, userId))
    {
        ApplyOrderByDescending(t => t.StartTime);
    }

    private static Expression<Func<TaskExecutionHistory, bool>> BuildSearchCriteria(string searchTerm, Guid? userId)
    {
        var predicate = PredicateBuilder.New<TaskExecutionHistory>(true);

        if (userId.HasValue)
        {
            predicate = predicate.And(t => t.UserId == userId.Value);
        }

        if (!string.IsNullOrEmpty(searchTerm))
        {
            predicate = predicate.And(t => 
                t.UserInput.Contains(searchTerm) || 
                t.ResultSummary.Contains(searchTerm) ||
                t.RequestType.Contains(searchTerm));
        }

        return predicate;
    }
}
```

### 4. è§„çº¦è¯„ä¼°å™¨

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data.Specifications/SpecificationEvaluator.cs`

```csharp
/// <summary>
/// è§„çº¦è¯„ä¼°å™¨ï¼Œå°†è§„çº¦è½¬æ¢ä¸ºEF CoreæŸ¥è¯¢
/// </summary>
public static class SpecificationEvaluator
{
    public static IQueryable<T> GetQuery<T>(IQueryable<T> inputQuery, ISpecification<T> specification) where T : class
    {
        var query = inputQuery;

        // åº”ç”¨è¿‡æ»¤æ¡ä»¶
        if (specification.Criteria != null)
        {
            query = query.Where(specification.Criteria);
        }

        // åº”ç”¨åŒ…å«
        query = specification.Includes.Aggregate(query, (current, include) => current.Include(include));
        query = specification.IncludeStrings.Aggregate(query, (current, include) => current.Include(include));

        // åº”ç”¨æ’åº
        if (specification.OrderBy != null)
        {
            query = query.OrderBy(specification.OrderBy);
        }
        else if (specification.OrderByDescending != null)
        {
            query = query.OrderByDescending(specification.OrderByDescending);
        }

        // åº”ç”¨ThenByæ’åº
        if (specification.OrderBy != null || specification.OrderByDescending != null)
        {
            var orderedQuery = (IOrderedQueryable<T>)query;
            
            foreach (var thenBy in specification.ThenBy)
            {
                orderedQuery = orderedQuery.ThenBy(thenBy);
            }
            
            foreach (var thenByDescending in specification.ThenByDescending)
            {
                orderedQuery = orderedQuery.ThenByDescending(thenByDescending);
            }
            
            query = orderedQuery;
        }

        // åº”ç”¨åˆ†é¡µ
        if (specification.IsPagingEnabled)
        {
            query = query.Skip(specification.Skip).Take(specification.Take);
        }

        return query;
    }
}
```

## æ•°æ®å®‰å…¨è®¾è®¡

### 1. åˆ†å±‚åŠ å¯†æ¶æ„

```mermaid
graph TB
    subgraph "å¯†é’¥ç®¡ç†å±‚"
        A[ä¸»å¯†é’¥ - DPAPIä¿æŠ¤]
        B[ç”¨æˆ·å¯†é’¥æ´¾ç”Ÿ - PBKDF2]
        C[æ•°æ®åŠ å¯†å¯†é’¥ - AES-256]
    end
    
    subgraph "æ•°æ®åŠ å¯†å±‚"
        D[æ•æ„Ÿå­—æ®µåŠ å¯†]
        E[JSONæ•°æ®åŠ å¯†]
        F[æ–‡ä»¶çº§åŠ å¯†]
    end
    
    subgraph "ä¼ è¾“åŠ å¯†å±‚"
        G[è¿›ç¨‹é—´é€šä¿¡åŠ å¯†]
        H[å¤‡ä»½ä¼ è¾“åŠ å¯†]
    end
    
    A --> B
    B --> C
    C --> D
    C --> E
    C --> F
    C --> G
    C --> H
```

### 2. åŠ å¯†æœåŠ¡å®ç°

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data/Security/EncryptionService.cs`

```csharp
/// <summary>
/// æ•°æ®åŠ å¯†æœåŠ¡
/// </summary>
public class EncryptionService : IEncryptionService
{
    private readonly IKeyManager _keyManager;
    private readonly ILogger<EncryptionService> _logger;

    public EncryptionService(IKeyManager keyManager, ILogger<EncryptionService> logger)
    {
        _keyManager = keyManager;
        _logger = logger;
    }

    public string Encrypt(string plainText, string keyId = null)
    {
        if (string.IsNullOrEmpty(plainText))
            return plainText;

        try
        {
            var key = _keyManager.GetKey(keyId ?? "default");
            using var aes = Aes.Create();
            aes.Key = key;
            aes.GenerateIV();

            using var encryptor = aes.CreateEncryptor();
            var plainBytes = Encoding.UTF8.GetBytes(plainText);
            var cipherBytes = encryptor.TransformFinalBlock(plainBytes, 0, plainBytes.Length);

            // ç»„åˆIVå’Œå¯†æ–‡
            var result = new byte[aes.IV.Length + cipherBytes.Length];
            Array.Copy(aes.IV, 0, result, 0, aes.IV.Length);
            Array.Copy(cipherBytes, 0, result, aes.IV.Length, cipherBytes.Length);

            return Convert.ToBase64String(result);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "æ•°æ®åŠ å¯†å¤±è´¥");
            throw new EncryptionException("æ•°æ®åŠ å¯†å¤±è´¥", ex);
        }
    }

    public string Decrypt(string cipherText, string keyId = null)
    {
        if (string.IsNullOrEmpty(cipherText))
            return cipherText;

        try
        {
            var key = _keyManager.GetKey(keyId ?? "default");
            var cipherBytes = Convert.FromBase64String(cipherText);

            using var aes = Aes.Create();
            aes.Key = key;

            // æå–IV
            var iv = new byte[aes.IV.Length];
            Array.Copy(cipherBytes, 0, iv, 0, iv.Length);
            aes.IV = iv;

            // æå–å¯†æ–‡
            var actualCipherBytes = new byte[cipherBytes.Length - iv.Length];
            Array.Copy(cipherBytes, iv.Length, actualCipherBytes, 0, actualCipherBytes.Length);

            using var decryptor = aes.CreateDecryptor();
            var plainBytes = decryptor.TransformFinalBlock(actualCipherBytes, 0, actualCipherBytes.Length);

            return Encoding.UTF8.GetString(plainBytes);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "æ•°æ®è§£å¯†å¤±è´¥");
            throw new DecryptionException("æ•°æ®è§£å¯†å¤±è´¥", ex);
        }
    }

    public byte[] EncryptBytes(byte[] plainBytes, string keyId = null)
    {
        if (plainBytes == null || plainBytes.Length == 0)
            return plainBytes;

        try
        {
            var key = _keyManager.GetKey(keyId ?? "default");
            using var aes = Aes.Create();
            aes.Key = key;
            aes.GenerateIV();

            using var encryptor = aes.CreateEncryptor();
            var cipherBytes = encryptor.TransformFinalBlock(plainBytes, 0, plainBytes.Length);

            // ç»„åˆIVå’Œå¯†æ–‡
            var result = new byte[aes.IV.Length + cipherBytes.Length];
            Array.Copy(aes.IV, 0, result, 0, aes.IV.Length);
            Array.Copy(cipherBytes, 0, result, aes.IV.Length, cipherBytes.Length);

            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "å­—èŠ‚æ•°æ®åŠ å¯†å¤±è´¥");
            throw new EncryptionException("å­—èŠ‚æ•°æ®åŠ å¯†å¤±è´¥", ex);
        }
    }

    public byte[] DecryptBytes(byte[] cipherBytes, string keyId = null)
    {
        if (cipherBytes == null || cipherBytes.Length == 0)
            return cipherBytes;

        try
        {
            var key = _keyManager.GetKey(keyId ?? "default");
            using var aes = Aes.Create();
            aes.Key = key;

            // æå–IV
            var iv = new byte[aes.IV.Length];
            Array.Copy(cipherBytes, 0, iv, 0, iv.Length);
            aes.IV = iv;

            // æå–å¯†æ–‡
            var actualCipherBytes = new byte[cipherBytes.Length - iv.Length];
            Array.Copy(cipherBytes, iv.Length, actualCipherBytes, 0, actualCipherBytes.Length);

            using var decryptor = aes.CreateDecryptor();
            return decryptor.TransformFinalBlock(actualCipherBytes, 0, actualCipherBytes.Length);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "å­—èŠ‚æ•°æ®è§£å¯†å¤±è´¥");
            throw new DecryptionException("å­—èŠ‚æ•°æ®è§£å¯†å¤±è´¥", ex);
        }
    }
}
```

### 3. å¯†é’¥ç®¡ç†å™¨

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data/Security/KeyManager.cs`

```csharp
/// <summary>
/// å¯†é’¥ç®¡ç†å™¨
/// </summary>
public class KeyManager : IKeyManager
{
    private readonly IConfiguration _configuration;
    private readonly ILogger<KeyManager> _logger;
    private readonly ConcurrentDictionary<string, byte[]> _keyCache = new();

    public KeyManager(IConfiguration configuration, ILogger<KeyManager> logger)
    {
        _configuration = configuration;
        _logger = logger;
    }

    public byte[] GetKey(string keyId)
    {
        return _keyCache.GetOrAdd(keyId, GenerateOrRetrieveKey);
    }

    public void RotateKey(string keyId)
    {
        _keyCache.TryRemove(keyId, out _);
        var newKey = GenerateNewKey();
        _keyCache.TryAdd(keyId, newKey);
        
        // ä¿å­˜æ–°å¯†é’¥åˆ°å®‰å…¨å­˜å‚¨
        SaveKeySecurely(keyId, newKey);
        
        _logger.LogInformation("å¯†é’¥ {KeyId} å·²è½®æ¢", keyId);
    }

    public bool KeyExists(string keyId)
    {
        return _keyCache.ContainsKey(keyId) || LoadKeyFromSecureStorage(keyId) != null;
    }

    private byte[] GenerateOrRetrieveKey(string keyId)
    {
        // é¦–å…ˆå°è¯•ä»å®‰å…¨å­˜å‚¨åŠ è½½
        var existingKey = LoadKeyFromSecureStorage(keyId);
        if (existingKey != null)
        {
            return existingKey;
        }

        // ç”Ÿæˆæ–°å¯†é’¥
        var newKey = GenerateNewKey();
        SaveKeySecurely(keyId, newKey);
        
        _logger.LogInformation("ä¸º {KeyId} ç”Ÿæˆæ–°å¯†é’¥", keyId);
        return newKey;
    }

    private byte[] GenerateNewKey()
    {
        using var rng = RandomNumberGenerator.Create();
        var key = new byte[32]; // 256ä½å¯†é’¥
        rng.GetBytes(key);
        return key;
    }

    private void SaveKeySecurely(string keyId, byte[] key)
    {
        try
        {
            // ä½¿ç”¨DPAPIä¿æŠ¤å¯†é’¥
            var protectedKey = ProtectedData.Protect(key, null, DataProtectionScope.CurrentUser);
            var keyPath = GetKeyFilePath(keyId);
            
            Directory.CreateDirectory(Path.GetDirectoryName(keyPath));
            File.WriteAllBytes(keyPath, protectedKey);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ä¿å­˜å¯†é’¥ {KeyId} å¤±è´¥", keyId);
            throw;
        }
    }

    private byte[] LoadKeyFromSecureStorage(string keyId)
    {
        try
        {
            var keyPath = GetKeyFilePath(keyId);
            if (!File.Exists(keyPath))
                return null;

            var protectedKey = File.ReadAllBytes(keyPath);
            return ProtectedData.Unprotect(protectedKey, null, DataProtectionScope.CurrentUser);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "åŠ è½½å¯†é’¥ {KeyId} å¤±è´¥", keyId);
            return null;
        }
    }

    private string GetKeyFilePath(string keyId)
    {
        var keyDirectory = _configuration["Security:KeyDirectory"] ?? 
                          Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), 
                                      "Lorn.OpenAgenticAI", "Keys");
        return Path.Combine(keyDirectory, $"{keyId}.key");
    }
}
```

## å¤‡ä»½æ¢å¤è®¾è®¡

### 1. å¤‡ä»½ç®¡ç†å™¨

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data/Backup/BackupManager.cs`

```csharp
/// <summary>
/// æ•°æ®åº“å¤‡ä»½ç®¡ç†å™¨
/// </summary>
public class BackupManager : IBackupManager
{
    private readonly OpenAgenticAIDbContext _context;
    private readonly IConfiguration _configuration;
    private readonly ILogger<BackupManager> _logger;
    private readonly string _backupDirectory;

    public BackupManager(
        OpenAgenticAIDbContext context,
        IConfiguration configuration,
        ILogger<BackupManager> logger)
    {
        _context = context;
        _configuration = configuration;
        _logger = logger;
        _backupDirectory = _configuration["Backup:Directory"] ?? 
                          Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), 
                                      "Lorn.OpenAgenticAI", "Backups");
        
        Directory.CreateDirectory(_backupDirectory);
    }

    public async Task<BackupResult> CreateBackupAsync(BackupType type, CancellationToken cancellationToken = default)
    {
        var backupId = Guid.NewGuid().ToString("N")[..8];
        var timestamp = DateTime.UtcNow;
        
        try
        {
            _logger.LogInformation("å¼€å§‹åˆ›å»º {BackupType} å¤‡ä»½: {BackupId}", type, backupId);
            
            return type switch
            {
                BackupType.Full => await CreateFullBackupAsync(backupId, timestamp, cancellationToken),
                BackupType.Incremental => await CreateIncrementalBackupAsync(backupId, timestamp, cancellationToken),
                BackupType.Differential => await CreateDifferentialBackupAsync(backupId, timestamp, cancellationToken),
                _ => throw new ArgumentException($"ä¸æ”¯æŒçš„å¤‡ä»½ç±»å‹: {type}")
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "åˆ›å»ºå¤‡ä»½å¤±è´¥: {BackupId}", backupId);
            await LogBackupErrorAsync(backupId, ex);
            throw new BackupException($"åˆ›å»ºå¤‡ä»½å¤±è´¥: {ex.Message}", ex);
        }
    }

    private async Task<BackupResult> CreateFullBackupAsync(string backupId, DateTime timestamp, CancellationToken cancellationToken)
    {
        var backupFileName = $"full_{timestamp:yyyyMMdd_HHmmss}_{backupId}.db";
        var backupPath = Path.Combine(_backupDirectory, backupFileName);
        
        try
        {
            // è·å–æ•°æ®åº“æ–‡ä»¶è·¯å¾„
            var connectionString = _context.Database.GetConnectionString();
            var dbPath = ExtractDatabasePath(connectionString);
            
            // æ‰§è¡ŒSQLiteå¤‡ä»½
            await ExecuteSqliteBackupAsync(dbPath, backupPath, cancellationToken);
            
            // å‹ç¼©å¤‡ä»½æ–‡ä»¶
            var compressedPath = await CompressBackupAsync(backupPath, cancellationToken);
            
            // éªŒè¯å¤‡ä»½å®Œæ•´æ€§
            var isValid = await ValidateBackupAsync(compressedPath, cancellationToken);
            
            var result = new BackupResult
            {
                BackupId = backupId,
                BackupType = BackupType.Full,
                BackupPath = compressedPath,
                IsSuccessful = isValid,
                DataSize = new FileInfo(compressedPath).Length,
                CreatedTime = timestamp,
                ValidationResult = isValid ? "å¤‡ä»½éªŒè¯æˆåŠŸ" : "å¤‡ä»½éªŒè¯å¤±è´¥"
            };
            
            // è®°å½•å¤‡ä»½ä¿¡æ¯
            await RecordBackupInfoAsync(result, cancellationToken);
            
            _logger.LogInformation("å®Œæ•´å¤‡ä»½åˆ›å»ºæˆåŠŸ: {BackupPath}, å¤§å°: {Size} bytes", 
                compressedPath, result.DataSize);
                
            return result;
        }
        catch (Exception ex)
        {
            // æ¸…ç†å¤±è´¥çš„å¤‡ä»½æ–‡ä»¶
            if (File.Exists(backupPath))
                File.Delete(backupPath);
                
            _logger.LogError(ex, "åˆ›å»ºå®Œæ•´å¤‡ä»½å¤±è´¥: {BackupId}", backupId);
            throw;
        }
    }

    private async Task<BackupResult> CreateIncrementalBackupAsync(string backupId, DateTime timestamp, CancellationToken cancellationToken)
    {
        var backupFileName = $"incremental_{timestamp:yyyyMMdd_HHmmss}_{backupId}.json";
        var backupPath = Path.Combine(_backupDirectory, backupFileName);
        
        try
        {
            // è·å–ä¸Šæ¬¡å¤‡ä»½æ—¶é—´
            var lastBackupTime = await GetLastBackupTimestampAsync(cancellationToken);
            
            // æŸ¥è¯¢å¢é‡æ•°æ®
            var incrementalData = await GetIncrementalDataAsync(lastBackupTime, cancellationToken);
            
            // åºåˆ—åŒ–å¢é‡æ•°æ®
            var jsonData = JsonSerializer.Serialize(incrementalData, new JsonSerializerOptions
            {
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            });
            
            // å†™å…¥å¤‡ä»½æ–‡ä»¶
            await File.WriteAllTextAsync(backupPath, jsonData, cancellationToken);
            
            // å‹ç¼©å¤‡ä»½æ–‡ä»¶
            var compressedPath = await CompressBackupAsync(backupPath, cancellationToken);
            
            var result = new BackupResult
            {
                BackupId = backupId,
                BackupType = BackupType.Incremental,
                BackupPath = compressedPath,
                IsSuccessful = true,
                DataSize = new FileInfo(compressedPath).Length,
                CreatedTime = timestamp,
                ValidationResult = "å¢é‡å¤‡ä»½åˆ›å»ºæˆåŠŸ"
            };
            
            await RecordBackupInfoAsync(result, cancellationToken);
            
            _logger.LogInformation("å¢é‡å¤‡ä»½åˆ›å»ºæˆåŠŸ: {BackupPath}, è®°å½•æ•°: {RecordCount}", 
                compressedPath, incrementalData.TotalRecords);
                
            return result;
        }
        catch (Exception ex)
        {
            if (File.Exists(backupPath))
                File.Delete(backupPath);
                
            _logger.LogError(ex, "åˆ›å»ºå¢é‡å¤‡ä»½å¤±è´¥: {BackupId}", backupId);
            throw;
        }
    }

    private async Task ExecuteSqliteBackupAsync(string sourcePath, string backupPath, CancellationToken cancellationToken)
    {
        using var sourceConnection = new SqliteConnection($"Data Source={sourcePath}");
        using var backupConnection = new SqliteConnection($"Data Source={backupPath}");
        
        await sourceConnection.OpenAsync(cancellationToken);
        await backupConnection.OpenAsync(cancellationToken);
        
        // ä½¿ç”¨SQLiteçš„å¤‡ä»½API
        sourceConnection.BackupDatabase(backupConnection);
    }

    private async Task<IncrementalBackupData> GetIncrementalDataAsync(DateTime since, CancellationToken cancellationToken)
    {
        var data = new IncrementalBackupData
        {
            BackupTimestamp = DateTime.UtcNow,
            SinceTimestamp = since
        };

        // è·å–æ–°å¢æˆ–ä¿®æ”¹çš„ç”¨æˆ·
        data.Users = await _context.UserProfiles
            .Where(u => u.CreatedTime > since || u.LastLoginTime > since)
            .ToListAsync(cancellationToken);

        // è·å–æ–°çš„ä»»åŠ¡æ‰§è¡Œè®°å½•
        data.TaskExecutions = await _context.TaskExecutionHistories
            .Where(t => t.StartTime > since)
            .Include(t => t.ExecutionSteps)
            .ToListAsync(cancellationToken);

        // è·å–æ–°çš„å·¥ä½œæµæ¨¡æ¿
        data.WorkflowTemplates = await _context.WorkflowTemplates
            .Where(w => w.CreatedTime > since || w.LastModifiedTime > since)
            .ToListAsync(cancellationToken);

        data.TotalRecords = data.Users.Count + data.TaskExecutions.Count + data.WorkflowTemplates.Count;
        
        return data;
    }

    private async Task<string> CompressBackupAsync(string backupPath, CancellationToken cancellationToken)
    {
        var compressedPath = backupPath + ".gz";
        
        using var originalFileStream = File.OpenRead(backupPath);
        using var compressedFileStream = File.Create(compressedPath);
        using var compressionStream = new GZipStream(compressedFileStream, CompressionMode.Compress);
        
        await originalFileStream.CopyToAsync(compressionStream, cancellationToken);
        
        // åˆ é™¤åŸå§‹æ–‡ä»¶
        File.Delete(backupPath);
        
        return compressedPath;
    }

    private async Task<bool> ValidateBackupAsync(string backupPath, CancellationToken cancellationToken)
    {
        try
        {
            // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”å¤§å°åˆç†
            var fileInfo = new FileInfo(backupPath);
            if (!fileInfo.Exists || fileInfo.Length == 0)
                return false;

            // å¦‚æœæ˜¯å‹ç¼©æ–‡ä»¶ï¼Œå°è¯•è§£å‹éªŒè¯
            if (backupPath.EndsWith(".gz"))
            {
                using var compressedStream = File.OpenRead(backupPath);
                using var decompressionStream = new GZipStream(compressedStream, CompressionMode.Decompress);
                using var memoryStream = new MemoryStream();
                
                await decompressionStream.CopyToAsync(memoryStream, cancellationToken);
                return memoryStream.Length > 0;
            }

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "å¤‡ä»½éªŒè¯å¤±è´¥: {BackupPath}", backupPath);
            return false;
        }
    }

    private async Task RecordBackupInfoAsync(BackupResult result, CancellationToken cancellationToken)
    {
        var backupRecord = new BackupRecord
        {
            BackupId = result.BackupId,
            BackupType = result.BackupType,
            BackupPath = result.BackupPath,
            DataSize = result.DataSize,
            CreatedTime = result.CreatedTime,
            IsSuccessful = result.IsSuccessful,
            ValidationResult = result.ValidationResult
        };

        // è¿™é‡Œå¯ä»¥å°†å¤‡ä»½è®°å½•ä¿å­˜åˆ°æ•°æ®åº“æˆ–æ—¥å¿—æ–‡ä»¶
        var recordPath = Path.Combine(_backupDirectory, "backup_records.json");
        var records = new List<BackupRecord>();
        
        if (File.Exists(recordPath))
        {
            var existingJson = await File.ReadAllTextAsync(recordPath, cancellationToken);
            records = JsonSerializer.Deserialize<List<BackupRecord>>(existingJson) ?? new List<BackupRecord>();
        }
        
        records.Add(backupRecord);
        
        // åªä¿ç•™æœ€è¿‘100æ¡è®°å½•
        if (records.Count > 100)
        {
            records = records.OrderByDescending(r => r.CreatedTime).Take(100).ToList();
        }
        
        var json = JsonSerializer.Serialize(records, new JsonSerializerOptions { WriteIndented = true });
        await File.WriteAllTextAsync(recordPath, json, cancellationToken);
    }

    private async Task<DateTime> GetLastBackupTimestampAsync(CancellationToken cancellationToken)
    {
        var recordPath = Path.Combine(_backupDirectory, "backup_records.json");
        
        if (!File.Exists(recordPath))
            return DateTime.MinValue;

        try
        {
            var json = await File.ReadAllTextAsync(recordPath, cancellationToken);
            var records = JsonSerializer.Deserialize<List<BackupRecord>>(json);
            
            return records?.Where(r => r.IsSuccessful)
                          .OrderByDescending(r => r.CreatedTime)
                          .FirstOrDefault()?.CreatedTime ?? DateTime.MinValue;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "è·å–ä¸Šæ¬¡å¤‡ä»½æ—¶é—´å¤±è´¥");
            return DateTime.MinValue;
        }
    }

    private async Task LogBackupErrorAsync(string backupId, Exception exception)
    {
        var errorLog = new BackupErrorLog
        {
            BackupId = backupId,
            ErrorMessage = exception.Message,
            StackTrace = exception.StackTrace,
            Timestamp = DateTime.UtcNow
        };

        var errorPath = Path.Combine(_backupDirectory, "backup_errors.json");
        var errors = new List<BackupErrorLog>();
        
        if (File.Exists(errorPath))
        {
            try
            {
                var existingJson = await File.ReadAllTextAsync(errorPath);
                errors = JsonSerializer.Deserialize<List<BackupErrorLog>>(existingJson) ?? new List<BackupErrorLog>();
            }
            catch
            {
                // å¿½ç•¥ååºåˆ—åŒ–é”™è¯¯
            }
        }
        
        errors.Add(errorLog);
        
        // åªä¿ç•™æœ€è¿‘50æ¡é”™è¯¯è®°å½•
        if (errors.Count > 50)
        {
            errors = errors.OrderByDescending(e => e.Timestamp).Take(50).ToList();
        }
        
        try
        {
            var json = JsonSerializer.Serialize(errors, new JsonSerializerOptions { WriteIndented = true });
            await File.WriteAllTextAsync(errorPath, json);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "è®°å½•å¤‡ä»½é”™è¯¯å¤±è´¥");
        }
    }

    private string ExtractDatabasePath(string connectionString)
    {
        var builder = new SqliteConnectionStringBuilder(connectionString);
        return builder.DataSource;
    }
}
```

### 2. æ•°æ®æ¢å¤ç®¡ç†å™¨

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data/Backup/RestoreManager.cs`

```csharp
/// <summary>
/// æ•°æ®æ¢å¤ç®¡ç†å™¨
/// </summary>
public class RestoreManager : IRestoreManager
{
    private readonly OpenAgenticAIDbContext _context;
    private readonly IConfiguration _configuration;
    private readonly ILogger<RestoreManager> _logger;
    private readonly string _backupDirectory;

    public RestoreManager(
        OpenAgenticAIDbContext context,
        IConfiguration configuration,
        ILogger<RestoreManager> logger)
    {
        _context = context;
        _configuration = configuration;
        _logger = logger;
        _backupDirectory = _configuration["Backup:Directory"] ?? 
                          Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), 
                                      "Lorn.OpenAgenticAI", "Backups");
    }

    public async Task<RestoreResult> RestoreFromBackupAsync(string backupPath, RestoreOptions options = null, CancellationToken cancellationToken = default)
    {
        var restoreId = Guid.NewGuid().ToString("N")[..8];
        options ??= new RestoreOptions();
        
        try
        {
            _logger.LogInformation("å¼€å§‹æ•°æ®æ¢å¤: {RestoreId}, å¤‡ä»½æ–‡ä»¶: {BackupPath}", restoreId, backupPath);
            
            // 1. éªŒè¯å¤‡ä»½æ–‡ä»¶
            var validationResult = await ValidateBackupFileAsync(backupPath, cancellationToken);
            if (!validationResult.IsValid)
            {
                return new RestoreResult
                {
                    RestoreId = restoreId,
                    IsSuccessful = false,
                    ErrorMessage = $"å¤‡ä»½æ–‡ä»¶éªŒè¯å¤±è´¥: {validationResult.ErrorMessage}",
                    StartTime = DateTime.UtcNow,
                    EndTime = DateTime.UtcNow
                };
            }

            var startTime = DateTime.UtcNow;
            
            // 2. åˆ›å»ºæ¢å¤ç‚¹ï¼ˆå¦‚æœéœ€è¦ï¼‰
            string recoveryPointPath = null;
            if (options.CreateRecoveryPoint)
            {
                recoveryPointPath = await CreateRecoveryPointAsync(restoreId, cancellationToken);
            }

            // 3. åœæ­¢æ•°æ®å†™å…¥ï¼ˆè®¾ç½®åªè¯»æ¨¡å¼ï¼‰
            await SetDatabaseReadOnlyAsync(true, cancellationToken);

            try
            {
                // 4. æ‰§è¡Œæ•°æ®æ¢å¤
                var restoreResult = await ExecuteRestoreAsync(backupPath, options, cancellationToken);
                
                // 5. æ•°æ®ä¸€è‡´æ€§æ£€æŸ¥
                var consistencyResult = await CheckDataConsistencyAsync(cancellationToken);
                
                if (!consistencyResult.IsConsistent)
                {
                    _logger.LogWarning("æ•°æ®ä¸€è‡´æ€§æ£€æŸ¥å¤±è´¥ï¼Œå›æ»šåˆ°æ¢å¤ç‚¹");
                    
                    if (!string.IsNullOrEmpty(recoveryPointPath))
                    {
                        await RollbackToRecoveryPointAsync(recoveryPointPath, cancellationToken);
                    }
                    
                    return new RestoreResult
                    {
                        RestoreId = restoreId,
                        IsSuccessful = false,
                        ErrorMessage = $"æ•°æ®ä¸€è‡´æ€§æ£€æŸ¥å¤±è´¥: {consistencyResult.ErrorMessage}",
                        StartTime = startTime,
                        EndTime = DateTime.UtcNow,
                        RecoveryPointPath = recoveryPointPath
                    };
                }

                return new RestoreResult
                {
                    RestoreId = restoreId,
                    IsSuccessful = true,
                    StartTime = startTime,
                    EndTime = DateTime.UtcNow,
                    RestoredRecords = restoreResult.RestoredRecords,
                    RecoveryPointPath = recoveryPointPath
                };
            }
            finally
            {
                // 6. æ¢å¤æ•°æ®å†™å…¥
                await SetDatabaseReadOnlyAsync(false, cancellationToken);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "æ•°æ®æ¢å¤å¤±è´¥: {RestoreId}", restoreId);
            
            return new RestoreResult
            {
                RestoreId = restoreId,
                IsSuccessful = false,
                ErrorMessage = ex.Message,
                StartTime = DateTime.UtcNow,
                EndTime = DateTime.UtcNow
            };
        }
    }

    private async Task<ValidationResult> ValidateBackupFileAsync(string backupPath, CancellationToken cancellationToken)
    {
        try
        {
            if (!File.Exists(backupPath))
            {
                return new ValidationResult { IsValid = false, ErrorMessage = "å¤‡ä»½æ–‡ä»¶ä¸å­˜åœ¨" };
            }

            var fileInfo = new FileInfo(backupPath);
            if (fileInfo.Length == 0)
            {
                return new ValidationResult { IsValid = false, ErrorMessage = "å¤‡ä»½æ–‡ä»¶ä¸ºç©º" };
            }

            // æ£€æŸ¥æ–‡ä»¶æ ¼å¼
            if (backupPath.EndsWith(".gz"))
            {
                // éªŒè¯å‹ç¼©æ–‡ä»¶
                using var compressedStream = File.OpenRead(backupPath);
                using var decompressionStream = new GZipStream(compressedStream, CompressionMode.Decompress);
                using var memoryStream = new MemoryStream();
                
                await decompressionStream.CopyToAsync(memoryStream, cancellationToken);
                
                if (memoryStream.Length == 0)
                {
                    return new ValidationResult { IsValid = false, ErrorMessage = "å‹ç¼©æ–‡ä»¶è§£å‹åä¸ºç©º" };
                }
            }
            else if (backupPath.EndsWith(".db"))
            {
                // éªŒè¯SQLiteæ•°æ®åº“æ–‡ä»¶
                using var connection = new SqliteConnection($"Data Source={backupPath}");
                await connection.OpenAsync(cancellationToken);
                
                var command = connection.CreateCommand();
                command.CommandText = "PRAGMA integrity_check";
                var result = await command.ExecuteScalarAsync(cancellationToken);
                
                if (result?.ToString() != "ok")
                {
                    return new ValidationResult { IsValid = false, ErrorMessage = "æ•°æ®åº“å®Œæ•´æ€§æ£€æŸ¥å¤±è´¥" };
                }
            }

            return new ValidationResult { IsValid = true };
        }
        catch (Exception ex)
        {
            return new ValidationResult { IsValid = false, ErrorMessage = ex.Message };
        }
    }

    private async Task<string> CreateRecoveryPointAsync(string restoreId, CancellationToken cancellationToken)
    {
        var recoveryPointPath = Path.Combine(_backupDirectory, $"recovery_point_{restoreId}_{DateTime.UtcNow:yyyyMMdd_HHmmss}.db");
        
        var connectionString = _context.Database.GetConnectionString();
        var currentDbPath = ExtractDatabasePath(connectionString);
        
        // åˆ›å»ºå½“å‰æ•°æ®åº“çš„å‰¯æœ¬ä½œä¸ºæ¢å¤ç‚¹
        File.Copy(currentDbPath, recoveryPointPath);
        
        _logger.LogInformation("åˆ›å»ºæ¢å¤ç‚¹: {RecoveryPointPath}", recoveryPointPath);
        
        return recoveryPointPath;
    }

    private async Task SetDatabaseReadOnlyAsync(bool readOnly, CancellationToken cancellationToken)
    {
        // è¿™é‡Œå¯ä»¥å®ç°æ•°æ®åº“åªè¯»æ¨¡å¼çš„è®¾ç½®
        // å¯¹äºSQLiteï¼Œå¯ä»¥é€šè¿‡è¿æ¥å­—ç¬¦ä¸²æˆ–PRAGMAè®¾ç½®
        if (readOnly)
        {
            await _context.Database.ExecuteSqlRawAsync("PRAGMA query_only = ON", cancellationToken);
        }
        else
        {
            await _context.Database.ExecuteSqlRawAsync("PRAGMA query_only = OFF", cancellationToken);
        }
    }

    private async Task<RestoreExecutionResult> ExecuteRestoreAsync(string backupPath, RestoreOptions options, CancellationToken cancellationToken)
    {
        if (backupPath.EndsWith(".db") || backupPath.EndsWith(".db.gz"))
        {
            return await RestoreFromDatabaseBackupAsync(backupPath, options, cancellationToken);
        }
        else if (backupPath.EndsWith(".json") || backupPath.EndsWith(".json.gz"))
        {
            return await RestoreFromIncrementalBackupAsync(backupPath, options, cancellationToken);
        }
        else
        {
            throw new NotSupportedException($"ä¸æ”¯æŒçš„å¤‡ä»½æ–‡ä»¶æ ¼å¼: {backupPath}");
        }
    }

    private async Task<RestoreExecutionResult> RestoreFromDatabaseBackupAsync(string backupPath, RestoreOptions options, CancellationToken cancellationToken)
    {
        var connectionString = _context.Database.GetConnectionString();
        var currentDbPath = ExtractDatabasePath(connectionString);
        
        // è§£å‹å¤‡ä»½æ–‡ä»¶ï¼ˆå¦‚æœéœ€è¦ï¼‰
        var actualBackupPath = backupPath;
        if (backupPath.EndsWith(".gz"))
        {
            actualBackupPath = await DecompressBackupAsync(backupPath, cancellationToken);
        }
        
        try
        {
            // å…³é—­å½“å‰è¿æ¥
            await _context.Database.CloseConnectionAsync();
            
            // æ›¿æ¢æ•°æ®åº“æ–‡ä»¶
            File.Copy(actualBackupPath, currentDbPath, true);
            
            // é‡æ–°æ‰“å¼€è¿æ¥
            await _context.Database.OpenConnectionAsync(cancellationToken);
            
            // è·å–æ¢å¤çš„è®°å½•æ•°
            var recordCount = await GetTotalRecordCountAsync(cancellationToken);
            
            return new RestoreExecutionResult
            {
                IsSuccessful = true,
                RestoredRecords = recordCount
            };
        }
        finally
        {
            // æ¸…ç†ä¸´æ—¶è§£å‹æ–‡ä»¶
            if (actualBackupPath != backupPath && File.Exists(actualBackupPath))
            {
                File.Delete(actualBackupPath);
            }
        }
    }

    private async Task<string> DecompressBackupAsync(string compressedPath, CancellationToken cancellationToken)
    {
        var decompressedPath = compressedPath.Replace(".gz", "");
        
        using var compressedStream = File.OpenRead(compressedPath);
        using var decompressionStream = new GZipStream(compressedStream, CompressionMode.Decompress);
        using var decompressedStream = File.Create(decompressedPath);
        
        await decompressionStream.CopyToAsync(decompressedStream, cancellationToken);
        
        return decompressedPath;
    }

    private async Task<DataConsistencyResult> CheckDataConsistencyAsync(CancellationToken cancellationToken)
    {
        try
        {
            // æ£€æŸ¥æ•°æ®åº“å®Œæ•´æ€§
            var integrityResult = await _context.Database.ExecuteSqlRawAsync("PRAGMA integrity_check", cancellationToken);
            
            // æ£€æŸ¥å¤–é”®çº¦æŸ
            var foreignKeyResult = await _context.Database.ExecuteSqlRawAsync("PRAGMA foreign_key_check", cancellationToken);
            
            // æ£€æŸ¥å…³é”®è¡¨æ˜¯å¦å­˜åœ¨æ•°æ®
            var userCount = await _context.UserProfiles.CountAsync(cancellationToken);
            
            return new DataConsistencyResult
            {
                IsConsistent = true,
                CheckedTables = new[] { "UserProfiles", "TaskExecutionHistory", "WorkflowTemplates" },
                TotalRecords = userCount
            };
        }
        catch (Exception ex)
        {
            return new DataConsistencyResult
            {
                IsConsistent = false,
                ErrorMessage = ex.Message
            };
        }
    }

    private async Task<int> GetTotalRecordCountAsync(CancellationToken cancellationToken)
    {
        var userCount = await _context.UserProfiles.CountAsync(cancellationToken);
        var taskCount = await _context.TaskExecutionHistories.CountAsync(cancellationToken);
        var workflowCount = await _context.WorkflowTemplates.CountAsync(cancellationToken);
        
        return userCount + taskCount + workflowCount;
    }

    private string ExtractDatabasePath(string connectionString)
    {
        var builder = new SqliteConnectionStringBuilder(connectionString);
        return builder.DataSource;
    }
}
```

## æ€§èƒ½ä¼˜åŒ–è®¾è®¡

### 1. ç¼“å­˜ç­–ç•¥å®ç°

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data/Caching/MultiLevelCacheManager.cs`

```csharp
/// <summary>
/// å¤šçº§ç¼“å­˜ç®¡ç†å™¨
/// </summary>
public class MultiLevelCacheManager : ICacheManager
{
    private readonly IMemoryCache _l1Cache;           // L1: è¿›ç¨‹å†…å­˜ç¼“å­˜
    private readonly IDistributedCache _l2Cache;      // L2: è¿›ç¨‹é—´å…±äº«ç¼“å­˜ï¼ˆå¯é€‰ï¼‰
    private readonly ILogger<MultiLevelCacheManager> _logger;
    
    // ç¼“å­˜ç­–ç•¥é…ç½®
    private readonly CacheStrategyConfig _config;

    public MultiLevelCacheManager(
        IMemoryCache memoryCache,
        IDistributedCache distributedCache,
        IOptions<CacheStrategyConfig> config,
        ILogger<MultiLevelCacheManager> logger)
    {
        _l1Cache = memoryCache;
        _l2Cache = distributedCache;
        _config = config.Value;
        _logger = logger;
    }

    public async Task<T> GetAsync<T>(string key, CancellationToken cancellationToken = default)
    {
        // 1. å°è¯•ä»L1ç¼“å­˜è·å–
        if (_l1Cache.TryGetValue(key, out T value))
        {
            _logger.LogDebug("L1ç¼“å­˜å‘½ä¸­: {Key}", key);
            return value;
        }

        // 2. å°è¯•ä»L2ç¼“å­˜è·å–
        if (_l2Cache != null)
        {
            var l2Value = await _l2Cache.GetAsync(key, cancellationToken);
            if (l2Value != null)
            {
                var deserializedValue = JsonSerializer.Deserialize<T>(l2Value);
                
                // å›å†™åˆ°L1ç¼“å­˜
                var l1Options = GetL1CacheOptions<T>();
                _l1Cache.Set(key, deserializedValue, l1Options);
                
                _logger.LogDebug("L2ç¼“å­˜å‘½ä¸­: {Key}", key);
                return deserializedValue;
            }
        }

        _logger.LogDebug("ç¼“å­˜æœªå‘½ä¸­: {Key}", key);
        return default(T);
    }

    public async Task SetAsync<T>(string key, T value, TimeSpan? expiry = null, CancellationToken cancellationToken = default)
    {
        if (value == null) return;

        var effectiveExpiry = expiry ?? GetDefaultExpiry<T>();

        // 1. è®¾ç½®L1ç¼“å­˜
        var l1Options = new MemoryCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = effectiveExpiry,
            Priority = GetCachePriority<T>(),
            Size = EstimateSize(value)
        };
        
        _l1Cache.Set(key, value, l1Options);

        // 2. è®¾ç½®L2ç¼“å­˜ï¼ˆå¦‚æœå¯ç”¨ï¼‰
        if (_l2Cache != null && ShouldUseL2Cache<T>())
        {
            var serializedValue = JsonSerializer.SerializeToUtf8Bytes(value);
            var l2Options = new DistributedCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = effectiveExpiry
            };
            
            await _l2Cache.SetAsync(key, serializedValue, l2Options, cancellationToken);
        }

        _logger.LogDebug("ç¼“å­˜å·²è®¾ç½®: {Key}, è¿‡æœŸæ—¶é—´: {Expiry}", key, effectiveExpiry);
    }

    public async Task RemoveAsync(string key, CancellationToken cancellationToken = default)
    {
        // ä»æ‰€æœ‰ç¼“å­˜å±‚ç§»é™¤
        _l1Cache.Remove(key);
        
        if (_l2Cache != null)
        {
            await _l2Cache.RemoveAsync(key, cancellationToken);
        }

        _logger.LogDebug("ç¼“å­˜å·²ç§»é™¤: {Key}", key);
    }

    public async Task<bool> ExistsAsync(string key, CancellationToken cancellationToken = default)
    {
        // æ£€æŸ¥L1ç¼“å­˜
        if (_l1Cache.TryGetValue(key, out _))
            return true;

        // æ£€æŸ¥L2ç¼“å­˜
        if (_l2Cache != null)
        {
            var value = await _l2Cache.GetAsync(key, cancellationToken);
            return value != null;
        }

        return false;
    }

    public async Task ClearAsync(string pattern = null, CancellationToken cancellationToken = default)
    {
        // L1ç¼“å­˜æ¸…ç†ï¼ˆéœ€è¦è‡ªå®šä¹‰å®ç°ï¼‰
        if (_l1Cache is MemoryCache memoryCache)
        {
            var field = typeof(MemoryCache).GetField("_coherentState", BindingFlags.NonPublic | BindingFlags.Instance);
            var coherentState = field?.GetValue(memoryCache);
            var entriesCollection = coherentState?.GetType().GetProperty("EntriesCollection", BindingFlags.NonPublic | BindingFlags.Instance);
            var entries = (IDictionary)entriesCollection?.GetValue(coherentState);

            if (entries != null)
            {
                var keysToRemove = new List<object>();
                foreach (DictionaryEntry entry in entries)
                {
                    if (pattern == null || entry.Key.ToString().Contains(pattern))
                    {
                        keysToRemove.Add(entry.Key);
                    }
                }

                foreach (var key in keysToRemove)
                {
                    _l1Cache.Remove(key);
                }
            }
        }

        _logger.LogInformation("ç¼“å­˜å·²æ¸…ç†, æ¨¡å¼: {Pattern}", pattern ?? "å…¨éƒ¨");
    }

    private TimeSpan GetDefaultExpiry<T>()
    {
        var typeName = typeof(T).Name;
        return typeName switch
        {
            nameof(UserProfile) => TimeSpan.FromHours(1),
            nameof(UserPreferences) => TimeSpan.FromHours(2),
            nameof(TaskExecutionHistory) => TimeSpan.FromMinutes(30),
            nameof(WorkflowTemplate) => TimeSpan.FromHours(4),
            _ => TimeSpan.FromMinutes(15)
        };
    }

    private CacheItemPriority GetCachePriority<T>()
    {
        var typeName = typeof(T).Name;
        return typeName switch
        {
            nameof(UserProfile) => CacheItemPriority.High,
            nameof(UserPreferences) => CacheItemPriority.High,
            nameof(WorkflowTemplate) => CacheItemPriority.Normal,
            _ => CacheItemPriority.Low
        };
    }

    private bool ShouldUseL2Cache<T>()
    {
        var typeName = typeof(T).Name;
        return typeName switch
        {
            nameof(UserProfile) => true,
            nameof(UserPreferences) => true,
            nameof(WorkflowTemplate) => true,
            _ => false
        };
    }

    private MemoryCacheEntryOptions GetL1CacheOptions<T>()
    {
        return new MemoryCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = GetDefaultExpiry<T>(),
            Priority = GetCachePriority<T>(),
            SlidingExpiration = TimeSpan.FromMinutes(5)
        };
    }

    private long EstimateSize<T>(T value)
    {
        // ç®€å•çš„å¤§å°ä¼°ç®—
        if (value is string str)
            return str.Length * 2; // Unicodeå­—ç¬¦

        if (value is ICollection collection)
            return collection.Count * 100; // ä¼°ç®—æ¯ä¸ªé¡¹ç›®100å­—èŠ‚

        return 1000; // é»˜è®¤ä¼°ç®—
    }
}
```

### 2. åˆ†é¡µæŸ¥è¯¢ä¼˜åŒ–

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data/Optimization/PaginatedQueryService.cs`

```csharp
/// <summary>
/// åˆ†é¡µæŸ¥è¯¢ä¼˜åŒ–æœåŠ¡
/// </summary>
public class PaginatedQueryService : IPaginatedQueryService
{
    private readonly OpenAgenticAIDbContext _context;
    private readonly ILogger<PaginatedQueryService> _logger;

    public PaginatedQueryService(OpenAgenticAIDbContext context, ILogger<PaginatedQueryService> logger)
    {
        _context = context;
        _logger = logger;
    }

    public async Task<PagedResult<T>> GetPagedAsync<T>(
        ISpecification<T> specification,
        int pageNumber,
        int pageSize,
        CancellationToken cancellationToken = default) where T : class
    {
        // å‚æ•°éªŒè¯
        if (pageNumber < 1) pageNumber = 1;
        if (pageSize < 1) pageSize = 10;
        if (pageSize > 1000) pageSize = 1000; // é™åˆ¶æœ€å¤§é¡µé¢å¤§å°

        var query = SpecificationEvaluator.GetQuery(_context.Set<T>().AsQueryable(), specification);

        // ä½¿ç”¨å¼‚æ­¥æ–¹å¼è·å–æ€»æ•°å’Œæ•°æ®
        var totalCountTask = query.CountAsync(cancellationToken);
        var itemsTask = query
            .Skip((pageNumber - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync(cancellationToken);

        await Task.WhenAll(totalCountTask, itemsTask);

        var totalCount = await totalCountTask;
        var items = await itemsTask;

        return new PagedResult<T>
        {
            Items = items,
            TotalCount = totalCount,
            PageNumber = pageNumber,
            PageSize = pageSize,
            TotalPages = (int)Math.Ceiling((double)totalCount / pageSize),
            HasNextPage = pageNumber * pageSize < totalCount,
            HasPreviousPage = pageNumber > 1
        };
    }

    public async Task<CursorPagedResult<T>> GetCursorPagedAsync<T, TKey>(
        ISpecification<T> specification,
        Expression<Func<T, TKey>> keySelector,
        TKey cursor,
        int pageSize,
        bool ascending = true,
        CancellationToken cancellationToken = default) where T : class
    {
        if (pageSize < 1) pageSize = 10;
        if (pageSize > 1000) pageSize = 1000;

        var query = SpecificationEvaluator.GetQuery(_context.Set<T>().AsQueryable(), specification);

        // åº”ç”¨æ¸¸æ ‡è¿‡æ»¤
        if (cursor != null && !cursor.Equals(default(TKey)))
        {
            if (ascending)
            {
                query = query.Where(BuildGreaterThanExpression(keySelector, cursor));
            }
            else
            {
                query = query.Where(BuildLessThanExpression(keySelector, cursor));
            }
        }

        // åº”ç”¨æ’åº
        query = ascending ? query.OrderBy(keySelector) : query.OrderByDescending(keySelector);

        // è·å–æ•°æ®ï¼ˆå¤šå–ä¸€æ¡ç”¨äºåˆ¤æ–­æ˜¯å¦æœ‰ä¸‹ä¸€é¡µï¼‰
        var items = await query.Take(pageSize + 1).ToListAsync(cancellationToken);

        var hasNextPage = items.Count > pageSize;
        if (hasNextPage)
        {
            items.RemoveAt(items.Count - 1);
        }

        TKey nextCursor = default(TKey);
        if (hasNextPage && items.Count > 0)
        {
            nextCursor = keySelector.Compile()(items.Last());
        }

        return new CursorPagedResult<T>
        {
            Items = items,
            NextCursor = nextCursor,
            HasNextPage = hasNextPage,
            PageSize = pageSize
        };
    }

    private Expression<Func<T, bool>> BuildGreaterThanExpression<T, TKey>(Expression<Func<T, TKey>> keySelector, TKey value)
    {
        var parameter = keySelector.Parameters[0];
        var property = keySelector.Body;
        var constant = Expression.Constant(value);
        var greaterThan = Expression.GreaterThan(property, constant);
        
        return Expression.Lambda<Func<T, bool>>(greaterThan, parameter);
    }

    private Expression<Func<T, bool>> BuildLessThanExpression<T, TKey>(Expression<Func<T, TKey>> keySelector, TKey value)
    {
        var parameter = keySelector.Parameters[0];
        var property = keySelector.Body;
        var constant = Expression.Constant(value);
        var lessThan = Expression.LessThan(property, constant);
        
        return Expression.Lambda<Func<T, bool>>(lessThan, parameter);
    }
}
```

### 3. æ•°æ®å‹ç¼©å’Œå½’æ¡£

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data/Optimization/DataCompressionService.cs`

```csharp
/// <summary>
/// æ•°æ®å‹ç¼©å’Œå½’æ¡£æœåŠ¡
/// </summary>
public class DataCompressionService : IDataCompressionService
{
    private readonly OpenAgenticAIDbContext _context;
    private readonly IConfiguration _configuration;
    private readonly ILogger<DataCompressionService> _logger;

    public DataCompressionService(
        OpenAgenticAIDbContext context,
        IConfiguration configuration,
        ILogger<DataCompressionService> logger)
    {
        _context = context;
        _configuration = configuration;
        _logger = logger;
    }

    public async Task<CompressionResult> CompressHistoricalDataAsync(CancellationToken cancellationToken = default)
    {
        var result = new CompressionResult
        {
            StartTime = DateTime.UtcNow
        };

        try
        {
            _logger.LogInformation("å¼€å§‹å†å²æ•°æ®å‹ç¼©");

            // 1. å‹ç¼©å¤§æ–‡æœ¬å­—æ®µ
            var textCompressionResult = await CompressLargeTextFieldsAsync(cancellationToken);
            result.CompressedTextFields = textCompressionResult.CompressedCount;
            result.TextCompressionSavings = textCompressionResult.SpaceSaved;

            // 2. å½’æ¡£å†·æ•°æ®
            var archiveResult = await ArchiveColdDataAsync(cancellationToken);
            result.ArchivedRecords = archiveResult.ArchivedCount;
            result.ArchiveSavings = archiveResult.SpaceSaved;

            // 3. æ¸…ç†é‡å¤æ•°æ®
            var deduplicationResult = await DeduplicateDataAsync(cancellationToken);
            result.DeduplicatedRecords = deduplicationResult.RemovedCount;
            result.DeduplicationSavings = deduplicationResult.SpaceSaved;

            // 4. å‹ç¼©æ•°æ®åº“
            var vacuumResult = await VacuumDatabaseAsync(cancellationToken);
            result.DatabaseCompressionSavings = vacuumResult.SpaceSaved;

            result.TotalSavings = result.TextCompressionSavings + 
                                 result.ArchiveSavings + 
                                 result.DeduplicationSavings + 
                                 result.DatabaseCompressionSavings;

            result.IsSuccessful = true;
            result.EndTime = DateTime.UtcNow;

            _logger.LogInformation("å†å²æ•°æ®å‹ç¼©å®Œæˆï¼ŒèŠ‚çœç©ºé—´: {Savings} bytes", result.TotalSavings);

            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "å†å²æ•°æ®å‹ç¼©å¤±è´¥");
            result.IsSuccessful = false;
            result.ErrorMessage = ex.Message;
            result.EndTime = DateTime.UtcNow;
            return result;
        }
    }

    private async Task<TextCompressionResult> CompressLargeTextFieldsAsync(CancellationToken cancellationToken)
    {
        var result = new TextCompressionResult();
        var compressionThreshold = _configuration.GetValue<int>("DataCompression:TextCompressionThreshold", 1000);

        // å‹ç¼©ä»»åŠ¡æ‰§è¡Œå†å²ä¸­çš„å¤§æ–‡æœ¬å­—æ®µ
        var largeTextExecutions = await _context.TaskExecutionHistories
            .Where(t => t.UserInput.Length > compressionThreshold || 
                       t.ResultSummary.Length > compressionThreshold)
            .ToListAsync(cancellationToken);

        foreach (var execution in largeTextExecutions)
        {
            var originalSize = 0L;
            var compressedSize = 0L;

            if (execution.UserInput?.Length > compressionThreshold)
            {
                originalSize += execution.UserInput.Length;
                var compressed = await CompressStringAsync(execution.UserInput);
                execution.UserInput = compressed;
                compressedSize += compressed.Length;
            }

            if (execution.ResultSummary?.Length > compressionThreshold)
            {
                originalSize += execution.ResultSummary.Length;
                var compressed = await CompressStringAsync(execution.ResultSummary);
                execution.ResultSummary = compressed;
                compressedSize += compressed.Length;
            }

            result.CompressedCount++;
            result.SpaceSaved += originalSize - compressedSize;
        }

        if (result.CompressedCount > 0)
        {
            await _context.SaveChangesAsync(cancellationToken);
        }

        return result;
    }

    private async Task<ArchiveResult> ArchiveColdDataAsync(CancellationToken cancellationToken)
    {
        var result = new ArchiveResult();
        var archiveThreshold = DateTime.UtcNow.AddDays(-_configuration.GetValue<int>("DataCompression:ColdDataThresholdDays", 180));

        // å½’æ¡£æ—§çš„ä»»åŠ¡æ‰§è¡Œè®°å½•
        var coldExecutions = await _context.TaskExecutionHistories
            .Where(t => t.StartTime < archiveThreshold)
            .Include(t => t.ExecutionSteps)
            .ToListAsync(cancellationToken);

        if (coldExecutions.Any())
        {
            // åˆ›å»ºå½’æ¡£æ–‡ä»¶
            var archiveData = new
            {
                ArchiveDate = DateTime.UtcNow,
                DataType = "TaskExecutionHistory",
                Records = coldExecutions.Select(t => new
                {
                    t.ExecutionId,
                    t.UserId,
                    t.UserInput,
                    t.StartTime,
                    t.EndTime,
                    t.IsSuccessful,
                    t.ResultSummary,
                    ExecutionSteps = t.ExecutionSteps.Select(s => new
                    {
                        s.StepRecordId,
                        s.StepId,
                        s.AgentId,
                        s.ActionName,
                        s.StartTime,
                        s.EndTime,
                        s.IsSuccessful
                    })
                })
            };

            var archiveFileName = $"archive_task_executions_{DateTime.UtcNow:yyyyMMdd_HHmmss}.json.gz";
            var archivePath = Path.Combine(GetArchiveDirectory(), archiveFileName);
            
            await SaveCompressedArchiveAsync(archiveData, archivePath, cancellationToken);

            // ä»ä¸»æ•°æ®åº“åˆ é™¤å·²å½’æ¡£çš„æ•°æ®
            _context.TaskExecutionHistories.RemoveRange(coldExecutions);
            await _context.SaveChangesAsync(cancellationToken);

            result.ArchivedCount = coldExecutions.Count;
            result.SpaceSaved = EstimateDataSize(coldExecutions);

            _logger.LogInformation("å½’æ¡£äº† {Count} æ¡å†·æ•°æ®åˆ° {ArchivePath}", result.ArchivedCount, archivePath);
        }

        return result;
    }

    private async Task<DeduplicationResult> DeduplicateDataAsync(CancellationToken cancellationToken)
    {
        var result = new DeduplicationResult();

        // æŸ¥æ‰¾é‡å¤çš„ä»»åŠ¡æ‰§è¡Œè®°å½•ï¼ˆåŸºäºç”¨æˆ·è¾“å…¥å’Œæ—¶é—´çª—å£ï¼‰
        var duplicateGroups = await _context.TaskExecutionHistories
            .GroupBy(t => new { t.UserId, t.UserInput, Date = t.StartTime.Date })
            .Where(g => g.Count() > 1)
            .Select(g => new { Key = g.Key, Count = g.Count(), Items = g.OrderBy(t => t.StartTime) })
            .ToListAsync(cancellationToken);

        foreach (var group in duplicateGroups)
        {
            // ä¿ç•™æœ€æ–°çš„è®°å½•ï¼Œåˆ é™¤å…¶ä»–é‡å¤è®°å½•
            var itemsToDelete = group.Items.Skip(1).ToList();
            
            foreach (var item in itemsToDelete)
            {
                _context.TaskExecutionHistories.Remove(item);
                result.RemovedCount++;
                result.SpaceSaved += EstimateDataSize(item);
            }
        }

        if (result.RemovedCount > 0)
        {
            await _context.SaveChangesAsync(cancellationToken);
            _logger.LogInformation("å»é‡åˆ é™¤äº† {Count} æ¡é‡å¤è®°å½•", result.RemovedCount);
        }

        return result;
    }

    private async Task<VacuumResult> VacuumDatabaseAsync(CancellationToken cancellationToken)
    {
        var result = new VacuumResult();

        try
        {
            // è·å–å‹ç¼©å‰çš„æ•°æ®åº“å¤§å°
            var beforeSize = await GetDatabaseSizeAsync(cancellationToken);

            // æ‰§è¡ŒVACUUMæ“ä½œ
            await _context.Database.ExecuteSqlRawAsync("VACUUM", cancellationToken);

            // è·å–å‹ç¼©åçš„æ•°æ®åº“å¤§å°
            var afterSize = await GetDatabaseSizeAsync(cancellationToken);

            result.SpaceSaved = beforeSize - afterSize;
            result.IsSuccessful = true;

            _logger.LogInformation("æ•°æ®åº“VACUUMå®Œæˆï¼ŒèŠ‚çœç©ºé—´: {Savings} bytes", result.SpaceSaved);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "æ•°æ®åº“VACUUMå¤±è´¥");
            result.IsSuccessful = false;
            result.ErrorMessage = ex.Message;
        }

        return result;
    }

    private async Task<string> CompressStringAsync(string input)
    {
        if (string.IsNullOrEmpty(input))
            return input;

        var bytes = Encoding.UTF8.GetBytes(input);
        using var memoryStream = new MemoryStream();
        using (var gzipStream = new GZipStream(memoryStream, CompressionMode.Compress))
        {
            await gzipStream.WriteAsync(bytes, 0, bytes.Length);
        }

        return Convert.ToBase64String(memoryStream.ToArray());
    }

    private async Task SaveCompressedArchiveAsync(object data, string filePath, CancellationToken cancellationToken)
    {
        var json = JsonSerializer.Serialize(data, new JsonSerializerOptions { WriteIndented = false });
        var bytes = Encoding.UTF8.GetBytes(json);

        Directory.CreateDirectory(Path.GetDirectoryName(filePath));

        using var fileStream = File.Create(filePath);
        using var gzipStream = new GZipStream(fileStream, CompressionMode.Compress);
        await gzipStream.WriteAsync(bytes, 0, bytes.Length, cancellationToken);
    }

    private async Task<long> GetDatabaseSizeAsync(CancellationToken cancellationToken)
    {
        var connectionString = _context.Database.GetConnectionString();
        var builder = new SqliteConnectionStringBuilder(connectionString);
        var dbPath = builder.DataSource;

        if (File.Exists(dbPath))
        {
            return new FileInfo(dbPath).Length;
        }

        return 0;
    }

    private string GetArchiveDirectory()
    {
        var archiveDir = _configuration["DataCompression:ArchiveDirectory"] ?? 
                        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), 
                                    "Lorn.OpenAgenticAI", "Archives");
        Directory.CreateDirectory(archiveDir);
        return archiveDir;
    }

    private long EstimateDataSize(object data)
    {
        // ç®€å•çš„æ•°æ®å¤§å°ä¼°ç®—
        var json = JsonSerializer.Serialize(data);
        return Encoding.UTF8.GetByteCount(json);
    }
}
```

## æœåŠ¡æ³¨å†Œå’Œé…ç½®

### 1. ä¾èµ–æ³¨å…¥é…ç½®

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data/ServiceCollectionExtensions.cs`

```csharp
/// <summary>
/// æ•°æ®è®¿é—®å±‚æœåŠ¡æ³¨å†Œæ‰©å±•
/// </summary>
public static class DataAccessServiceCollectionExtensions
{
    /// <summary>
    /// æ³¨å†Œæ•°æ®è®¿é—®å±‚æœåŠ¡
    /// </summary>
    public static IServiceCollection AddDataAccessServices(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // 1. æ³¨å†Œæ•°æ®åº“ä¸Šä¸‹æ–‡
        services.AddSqliteDatabase(configuration);
        
        // 2. æ³¨å†Œä»“å‚¨æœåŠ¡
        services.AddRepositories();
        
        // 3. æ³¨å†Œå·¥ä½œå•å…ƒ
        services.AddScoped<IUnitOfWork, UnitOfWork>();
        
        // 4. æ³¨å†Œç¼“å­˜æœåŠ¡
        services.AddCachingServices(configuration);
        
        // 5. æ³¨å†Œå®‰å…¨æœåŠ¡
        services.AddSecurityServices(configuration);
        
        // 6. æ³¨å†Œå¤‡ä»½æœåŠ¡
        services.AddBackupServices(configuration);
        
        // 7. æ³¨å†Œæ€§èƒ½ä¼˜åŒ–æœåŠ¡
        services.AddOptimizationServices(configuration);
        
        // 8. æ³¨å†Œç›‘æ§æœåŠ¡
        services.AddMonitoringServices(configuration);
        
        return services;
    }
    
    private static IServiceCollection AddRepositories(this IServiceCollection services)
    {
        // æ³¨å†ŒåŸºç¡€ä»“å‚¨
        services.AddScoped(typeof(IRepository<>), typeof(RepositoryBase<>));
        
        // æ³¨å†Œä¸“é—¨ä»“å‚¨
        services.AddScoped<IUserProfileRepository, UserProfileRepository>();
        services.AddScoped<ITaskExecutionHistoryRepository, TaskExecutionHistoryRepository>();
        services.AddScoped<IWorkflowTemplateRepository, WorkflowTemplateRepository>();
        services.AddScoped<IModelProviderRepository, ModelProviderRepository>();
        services.AddScoped<IModelRepository, ModelRepository>();
        services.AddScoped<IMCPConfigurationRepository, MCPConfigurationRepository>();
        services.AddScoped<IAgentCapabilityRepository, AgentCapabilityRepository>();
        
        return services;
    }
    
    private static IServiceCollection AddCachingServices(this IServiceCollection services, IConfiguration configuration)
    {
        // é…ç½®å†…å­˜ç¼“å­˜
        services.AddMemoryCache(options =>
        {
            options.SizeLimit = configuration.GetValue<long>("Caching:MemoryCache:SizeLimit", 100_000_000); // 100MB
            options.CompactionPercentage = configuration.GetValue<double>("Caching:MemoryCache:CompactionPercentage", 0.25);
        });
        
        // é…ç½®åˆ†å¸ƒå¼ç¼“å­˜ï¼ˆå¯é€‰ï¼‰
        var distributedCacheType = configuration.GetValue<string>("Caching:DistributedCache:Type");
        if (!string.IsNullOrEmpty(distributedCacheType))
        {
            switch (distributedCacheType.ToLower())
            {
                case "redis":
                    services.AddStackExchangeRedisCache(options =>
                    {
                        options.Configuration = configuration.GetConnectionString("Redis");
                    });
                    break;
                case "sqlserver":
                    services.AddDistributedSqlServerCache(options =>
                    {
                        options.ConnectionString = configuration.GetConnectionString("DistributedCache");
                        options.SchemaName = "dbo";
                        options.TableName = "DataCache";
                    });
                    break;
            }
        }
        
        // æ³¨å†Œç¼“å­˜ç®¡ç†å™¨
        services.AddScoped<ICacheManager, MultiLevelCacheManager>();
        
        // é…ç½®ç¼“å­˜ç­–ç•¥
        services.Configure<CacheStrategyConfig>(configuration.GetSection("Caching:Strategy"));
        
        return services;
    }
    
    private static IServiceCollection AddSecurityServices(this IServiceCollection services, IConfiguration configuration)
    {
        // æ³¨å†ŒåŠ å¯†æœåŠ¡
        services.AddScoped<IEncryptionService, EncryptionService>();
        services.AddScoped<IKeyManager, KeyManager>();
        
        // æ³¨å†Œè®¿é—®æ§åˆ¶æœåŠ¡
        services.AddScoped<IAccessControlService, AccessControlService>();
        
        // é…ç½®å®‰å…¨é€‰é¡¹
        services.Configure<SecurityOptions>(configuration.GetSection("Security"));
        
        return services;
    }
    
    private static IServiceCollection AddBackupServices(this IServiceCollection services, IConfiguration configuration)
    {
        // æ³¨å†Œå¤‡ä»½æœåŠ¡
        services.AddScoped<IBackupManager, BackupManager>();
        services.AddScoped<IRestoreManager, RestoreManager>();
        
        // é…ç½®å¤‡ä»½é€‰é¡¹
        services.Configure<BackupOptions>(configuration.GetSection("Backup"));
        
        return services;
    }
    
    private static IServiceCollection AddOptimizationServices(this IServiceCollection services, IConfiguration configuration)
    {
        // æ³¨å†Œæ€§èƒ½ä¼˜åŒ–æœåŠ¡
        services.AddScoped<IIndexOptimizer, IndexOptimizer>();
        services.AddScoped<IPaginatedQueryService, PaginatedQueryService>();
        services.AddScoped<IDataCompressionService, DataCompressionService>();
        
        // é…ç½®ä¼˜åŒ–é€‰é¡¹
        services.Configure<OptimizationOptions>(configuration.GetSection("DataOptimization"));
        
        return services;
    }
    
    private static IServiceCollection AddMonitoringServices(this IServiceCollection services, IConfiguration configuration)
    {
        // æ³¨å†Œç›‘æ§æœåŠ¡
        services.AddScoped<IStorageMonitor, StorageMonitor>();
        services.AddScoped<IDataIntegrityChecker, DataIntegrityChecker>();
        
        // é…ç½®ç›‘æ§é€‰é¡¹
        services.Configure<MonitoringOptions>(configuration.GetSection("Monitoring"));
        
        return services;
    }
}
```

### 2. é…ç½®æ–‡ä»¶ç¤ºä¾‹

**æ–‡ä»¶ä½ç½®**: `appsettings.json`

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Data Source=openagenticai.db;Cache=Shared;Foreign Keys=True;",
    "Redis": "localhost:6379",
    "DistributedCache": "Server=(localdb)\\mssqllocaldb;Database=OpenAgenticAI_Cache;Trusted_Connection=true;"
  },
  
  "Caching": {
    "MemoryCache": {
      "SizeLimit": 100000000,
      "CompactionPercentage": 0.25
    },
    "DistributedCache": {
      "Type": "redis"
    },
    "Strategy": {
      "DefaultExpiry": "00:15:00",
      "UserProfileExpiry": "01:00:00",
      "UserPreferencesExpiry": "02:00:00",
      "TaskExecutionHistoryExpiry": "00:30:00",
      "WorkflowTemplateExpiry": "04:00:00"
    }
  },
  
  "Security": {
    "KeyDirectory": "%LOCALAPPDATA%\\Lorn.OpenAgenticAI\\Keys",
    "EncryptionAlgorithm": "AES-256-GCM",
    "KeyRotationInterval": "90.00:00:00",
    "RequireEncryption": true
  },
  
  "Backup": {
    "Directory": "%LOCALAPPDATA%\\Lorn.OpenAgenticAI\\Backups",
    "AutoBackup": {
      "Enabled": true,
      "FullBackupInterval": "1.00:00:00",
      "IncrementalBackupInterval": "01:00:00",
      "RetentionDays": 30
    },
    "Compression": {
      "Enabled": true,
      "CompressionLevel": "Optimal"
    }
  },
  
  "DataOptimization": {
    "TextCompressionThreshold": 1000,
    "ColdDataThresholdDays": 180,
    "ArchiveDirectory": "%LOCALAPPDATA%\\Lorn.OpenAgenticAI\\Archives",
    "AutoOptimization": {
      "Enabled": true,
      "IndexOptimizationInterval": "7.00:00:00",
      "DataCompressionInterval": "1.00:00:00",
      "VacuumInterval": "7.00:00:00"
    }
  },
  
  "Monitoring": {
    "HealthCheck": {
      "Enabled": true,
      "CheckInterval": "00:05:00"
    },
    "Metrics": {
      "Enabled": true,
      "CollectionInterval": "00:01:00",
      "RetentionDays": 7
    },
    "Alerts": {
      "DatabaseSizeThreshold": 1073741824,
      "QueryTimeThreshold": "00:00:05",
      "ErrorRateThreshold": 0.05
    }
  }
}
```

### 3. åº”ç”¨ç¨‹åºå¯åŠ¨é…ç½®

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.MAUI/MauiProgram.cs`

```csharp
public static class MauiProgram
{
    public static MauiApp CreateMauiApp()
    {
        var builder = MauiApp.CreateBuilder();
        builder
            .UseMauiApp<App>()
            .ConfigureFonts(fonts =>
            {
                fonts.AddFont("OpenSans-Regular.ttf", "OpenSansRegular");
            });

        // é…ç½®æœåŠ¡
        ConfigureServices(builder.Services, builder.Configuration);

        return builder.Build();
    }

    private static void ConfigureServices(IServiceCollection services, IConfiguration configuration)
    {
        // 1. æ·»åŠ æ•°æ®è®¿é—®å±‚æœåŠ¡
        services.AddDataAccessServices(configuration);
        
        // 2. æ·»åŠ åº”ç”¨æœåŠ¡
        services.AddApplicationServices(configuration);
        
        // 3. æ·»åŠ é¢†åŸŸæœåŠ¡
        services.AddDomainServices(configuration);
        
        // 4. æ·»åŠ åŸºç¡€è®¾æ–½æœåŠ¡
        services.AddInfrastructureServices(configuration);
        
        // 5. é…ç½®æ—¥å¿—
        services.AddLogging(builder =>
        {
            builder.AddConsole();
            builder.AddDebug();
            builder.AddFile(configuration.GetSection("Logging:File"));
        });
        
        // 6. æ·»åŠ å¥åº·æ£€æŸ¥
        services.AddHealthChecks()
            .AddDbContextCheck<OpenAgenticAIDbContext>()
            .AddCheck<DatabaseHealthCheck>("database")
            .AddCheck<BackupHealthCheck>("backup")
            .AddCheck<CacheHealthCheck>("cache");
    }
}
```

## ç›‘æ§å’Œè¯Šæ–­

### 1. å­˜å‚¨ç›‘æ§æœåŠ¡

**é¡¹ç›®ä½ç½®**: `Lorn.OpenAgenticAI.Infrastructure.Data/Monitoring/StorageMonitor.cs`

```csharp
/// <summary>
/// å­˜å‚¨ç›‘æ§æœåŠ¡
/// </summary>
public class StorageMonitor : IStorageMonitor
{
    private readonly OpenAgenticAIDbContext _context;
    private readonly IConfiguration _configuration;
    private readonly ILogger<StorageMonitor> _logger;

    public StorageMonitor(
        OpenAgenticAIDbContext context,
        IConfiguration configuration,
        ILogger<StorageMonitor> logger)
    {
        _context = context;
        _configuration = configuration;
        _logger = logger;
    }

    public async Task<DataStorageMetrics> GetMetricsAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            var metrics = new DataStorageMetrics
            {
                CollectionTime = DateTime.UtcNow
            };

            // 1. æ•°æ®åº“å¤§å°ä¿¡æ¯
            var dbSize = await GetDatabaseSizeAsync(cancellationToken);
            metrics.TotalStorageSize = dbSize.TotalSize;
            metrics.DataSize = dbSize.DataSize;
            metrics.IndexSize = dbSize.IndexSize;
            metrics.FreeSpace = dbSize.FreeSpace;

            // 2. æŸ¥è¯¢æ€§èƒ½æŒ‡æ ‡
            var queryMetrics = await GetQueryPerformanceMetricsAsync(cancellationToken);
            metrics.AverageQueryTime = queryMetrics.AverageQueryTime;
            metrics.SlowQueryCount = queryMetrics.SlowQueryCount;
            metrics.QueryCount = queryMetrics.TotalQueryCount;

            // 3. è¿æ¥ä¿¡æ¯
            metrics.ActiveConnections = await GetActiveConnectionCountAsync(cancellationToken);

            // 4. ç¼“å­˜æŒ‡æ ‡
            var cacheMetrics = await GetCacheMetricsAsync(cancellationToken);
            metrics.CacheHitRatio = cacheMetrics.HitRatio;
            metrics.CacheSize = cacheMetrics.Size;

            // 5. å¤‡ä»½ä¿¡æ¯
            var backupMetrics = await GetBackupMetricsAsync(cancellationToken);
            metrics.LastBackupTime = backupMetrics.LastBackupTime;
            metrics.BackupSuccessRate = backupMetrics.SuccessRate;

            // 6. æ•°æ®å¢é•¿ç‡
            metrics.DatabaseGrowthRate = await CalculateDatabaseGrowthRateAsync(cancellationToken);

            return metrics;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "è·å–å­˜å‚¨æŒ‡æ ‡å¤±è´¥");
            throw;
        }
    }

    public async Task<bool> CheckHealthAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            // 1. æ£€æŸ¥æ•°æ®åº“è¿æ¥
            var canConnect = await _context.Database.CanConnectAsync(cancellationToken);
            if (!canConnect) return false;

            // 2. æ£€æŸ¥æ•°æ®åº“å®Œæ•´æ€§
            var integrityResult = await _context.Database.ExecuteSqlRawAsync("PRAGMA integrity_check", cancellationToken);
            
            // 3. æ£€æŸ¥ç£ç›˜ç©ºé—´
            var dbPath = GetDatabasePath();
            var drive = new DriveInfo(Path.GetPathRoot(dbPath));
            var freeSpaceGB = drive.AvailableFreeSpace / (1024.0 * 1024.0 * 1024.0);
            
            if (freeSpaceGB < 1.0) // å°‘äº1GBå¯ç”¨ç©ºé—´
            {
                _logger.LogWarning("ç£ç›˜ç©ºé—´ä¸è¶³: {FreeSpace:F2} GB", freeSpaceGB);
                return false;
            }

            // 4. æ£€æŸ¥å¤‡ä»½çŠ¶æ€
            var lastBackupTime = await GetLastBackupTimeAsync(cancellationToken);
            var backupAge = DateTime.UtcNow - lastBackupTime;
            
            if (backupAge.TotalHours > 25) // è¶…è¿‡25å°æ—¶æ²¡æœ‰å¤‡ä»½
            {
                _logger.LogWarning("å¤‡ä»½è¿‡æœŸ: ä¸Šæ¬¡å¤‡ä»½æ—¶é—´ {LastBackup}", lastBackupTime);
                return false;
            }

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "å¥åº·æ£€æŸ¥å¤±è´¥");
            return false;
        }
    }

    public async Task<IEnumerable<PerformanceAlert>> GetAlertsAsync(CancellationToken cancellationToken = default)
    {
        var alerts = new List<PerformanceAlert>();

        try
        {
            var metrics = await GetMetricsAsync(cancellationToken);
            var thresholds = _configuration.GetSection("Monitoring:Alerts").Get<AlertThresholds>();

            // æ•°æ®åº“å¤§å°å‘Šè­¦
            if (metrics.TotalStorageSize > thresholds.DatabaseSizeThreshold)
            {
                alerts.Add(new PerformanceAlert
                {
                    Type = AlertType.DatabaseSize,
                    Severity = AlertSeverity.Warning,
                    Message = $"æ•°æ®åº“å¤§å°è¶…è¿‡é˜ˆå€¼: {metrics.TotalStorageSize / (1024 * 1024):F2} MB",
                    Timestamp = DateTime.UtcNow,
                    Value = metrics.TotalStorageSize,
                    Threshold = thresholds.DatabaseSizeThreshold
                });
            }

            // æŸ¥è¯¢æ—¶é—´å‘Šè­¦
            if (metrics.AverageQueryTime > thresholds.QueryTimeThreshold)
            {
                alerts.Add(new PerformanceAlert
                {
                    Type = AlertType.QueryPerformance,
                    Severity = AlertSeverity.Warning,
                    Message = $"å¹³å‡æŸ¥è¯¢æ—¶é—´è¿‡é•¿: {metrics.AverageQueryTime.TotalMilliseconds:F2} ms",
                    Timestamp = DateTime.UtcNow,
                    Value = metrics.AverageQueryTime.TotalMilliseconds,
                    Threshold = thresholds.QueryTimeThreshold.TotalMilliseconds
                });
            }

            // ç¼“å­˜å‘½ä¸­ç‡å‘Šè­¦
            if (metrics.CacheHitRatio < thresholds.CacheHitRatioThreshold)
            {
                alerts.Add(new PerformanceAlert
                {
                    Type = AlertType.CachePerformance,
                    Severity = AlertSeverity.Info,
                    Message = $"ç¼“å­˜å‘½ä¸­ç‡è¾ƒä½: {metrics.CacheHitRatio:P2}",
                    Timestamp = DateTime.UtcNow,
                    Value = metrics.CacheHitRatio,
                    Threshold = thresholds.CacheHitRatioThreshold
                });
            }

            // å¤‡ä»½å‘Šè­¦
            var backupAge = DateTime.UtcNow - metrics.LastBackupTime;
            if (backupAge.TotalHours > thresholds.BackupAgeThresholdHours)
            {
                alerts.Add(new PerformanceAlert
                {
                    Type = AlertType.BackupAge,
                    Severity = AlertSeverity.Critical,
                    Message = $"å¤‡ä»½è¿‡æœŸ: {backupAge.TotalHours:F1} å°æ—¶å‰",
                    Timestamp = DateTime.UtcNow,
                    Value = backupAge.TotalHours,
                    Threshold = thresholds.BackupAgeThresholdHours
                });
            }

            return alerts;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "è·å–å‘Šè­¦ä¿¡æ¯å¤±è´¥");
            return alerts;
        }
    }

    private async Task<DatabaseSizeInfo> GetDatabaseSizeAsync(CancellationToken cancellationToken)
    {
        var dbPath = GetDatabasePath();
        var fileInfo = new FileInfo(dbPath);
        
        var sizeInfo = new DatabaseSizeInfo
        {
            TotalSize = fileInfo.Length
        };

        // è·å–è¯¦ç»†çš„æ•°æ®åº“å¤§å°ä¿¡æ¯
        using var command = _context.Database.GetDbConnection().CreateCommand();
        command.CommandText = @"
            SELECT 
                SUM(pgsize) as total_pages,
                SUM(CASE WHEN name LIKE 'sqlite_%' THEN pgsize ELSE 0 END) as index_pages
            FROM dbstat";

        await _context.Database.OpenConnectionAsync(cancellationToken);
        using var reader = await command.ExecuteReaderAsync(cancellationToken);
        
        if (await reader.ReadAsync(cancellationToken))
        {
            var totalPages = reader.GetInt64("total_pages");
            var indexPages = reader.GetInt64("index_pages");
            var pageSize = 4096; // SQLiteé»˜è®¤é¡µé¢å¤§å°
            
            sizeInfo.DataSize = (totalPages - indexPages) * pageSize;
            sizeInfo.IndexSize = indexPages * pageSize;
        }

        return sizeInfo;
    }

    private string GetDatabasePath()
    {
        var connectionString = _context.Database.GetConnectionString();
        var builder = new SqliteConnectionStringBuilder(connectionString);
        return builder.DataSource;
    }
}
```

## æ€»ç»“

æœ¬æŠ€æœ¯è®¾è®¡æ–‡æ¡£åŸºäºå·²æœ‰çš„æŠ€æœ¯æ¶æ„ï¼Œè¯¦ç»†æè¿°äº†æœ¬åœ°æ•°æ®ç®¡ç†åŠŸèƒ½çš„å®Œæ•´å®ç°æ–¹æ¡ˆï¼Œä¸»è¦ç‰¹ç‚¹åŒ…æ‹¬ï¼š

### æ¶æ„ä¼˜åŠ¿

1. **æ•°æ®åº“æ— å…³æ€§**ï¼šé€šè¿‡æŠ½è±¡å±‚è®¾è®¡ï¼Œæ”¯æŒå¤šç§æ•°æ®åº“åˆ‡æ¢
2. **æ¸…æ™°çš„åˆ†å±‚**ï¼šæ¥å£ã€å®ç°ã€ä¸“é—¨åŒ–ä»“å‚¨çš„å±‚æ¬¡åŒ–ç»„ç»‡
3. **é«˜æ€§èƒ½**ï¼šå¤šçº§ç¼“å­˜ç­–ç•¥ã€æ™ºèƒ½ç´¢å¼•ã€æŸ¥è¯¢ä¼˜åŒ–
4. **é«˜å¯é æ€§**ï¼šè‡ªåŠ¨å¤‡ä»½ã€æ•°æ®å®Œæ•´æ€§æ£€æŸ¥ã€æ•…éšœæ¢å¤
5. **é«˜å®‰å…¨æ€§**ï¼šåˆ†å±‚åŠ å¯†ã€è®¿é—®æ§åˆ¶ã€å®¡è®¡æ—¥å¿—
6. **å¯æ‰©å±•æ€§**ï¼šè§„çº¦æ¨¡å¼ã€æ³›å‹è®¾è®¡ã€æ’ä»¶åŒ–æ¶æ„

### å…³é”®æŠ€æœ¯ç‰¹æ€§

- **å¼‚æ­¥ä¼˜å…ˆ**ï¼šæ‰€æœ‰æ•°æ®åº“æ“ä½œæ”¯æŒå¼‚æ­¥å’Œå–æ¶ˆä»¤ç‰Œ
- **å¼ºç±»å‹å®‰å…¨**ï¼šæ³›å‹çº¦æŸã€è¡¨è¾¾å¼æ ‘ã€ç¼–è¯‘æ—¶æ£€æŸ¥
- **çµæ´»æŸ¥è¯¢**ï¼šè§„çº¦æ¨¡å¼æ”¯æŒå¤æ‚æŸ¥è¯¢é€»è¾‘ç»„åˆ
- **äº‹åŠ¡ç®¡ç†**ï¼šå·¥ä½œå•å…ƒæ¨¡å¼ç¡®ä¿æ•°æ®ä¸€è‡´æ€§
- **æ€§èƒ½ç›‘æ§**ï¼šå¥åº·æ£€æŸ¥ã€æŒ‡æ ‡æ”¶é›†ã€å‘Šè­¦æœºåˆ¶

### å®ç°æŒ‡å¯¼

1. **é¡¹ç›®åˆ›å»º**ï¼šæŒ‰ç…§ä¾èµ–å…³ç³»å›¾åˆ›å»ºå¯¹åº”çš„é¡¹ç›®å’Œå¼•ç”¨
2. **æ¥å£ä¼˜å…ˆ**ï¼šå…ˆå®šä¹‰æ¥å£å¥‘çº¦ï¼Œå†å®ç°å…·ä½“åŠŸèƒ½
3. **æ¸è¿›å¼å¼€å‘**ï¼šä»åŸºç¡€ä»“å‚¨å¼€å§‹ï¼Œé€æ­¥æ·»åŠ ä¸“é—¨åŒ–åŠŸèƒ½
4. **æµ‹è¯•é©±åŠ¨**ï¼šä¸ºæ¯ä¸ªä»“å‚¨å’Œè§„çº¦ç¼–å†™å•å…ƒæµ‹è¯•
5. **æ€§èƒ½è°ƒä¼˜**ï¼šæ ¹æ®å®é™…ä½¿ç”¨æƒ…å†µè°ƒæ•´ç¼“å­˜å’ŒæŸ¥è¯¢ç­–ç•¥

è¿™ç§è®¾è®¡ä¸ºLorn.OpenAgenticAIé¡¹ç›®æä¾›äº†åšå®çš„æ•°æ®è®¿é—®åŸºç¡€ï¼Œæ”¯æŒé«˜å¹¶å‘ã€é«˜æ€§èƒ½çš„æ™ºèƒ½ä½“å¹³å°éœ€æ±‚ï¼ŒåŒæ—¶ä¿æŒäº†è‰¯å¥½çš„å¯ç»´æŠ¤æ€§å’Œå¯æ‰©å±•æ€§ã€‚

## æ€»ç»“

æœ¬è®¾è®¡æ–‡æ¡£æä¾›äº†æœ¬åœ°æ•°æ®ç®¡ç†åŠŸèƒ½çš„å®Œæ•´æŠ€æœ¯æ–¹æ¡ˆï¼Œæ¶µç›–äº†æ•°æ®å­˜å‚¨ã€å®‰å…¨ã€å¤‡ä»½ã€æ€§èƒ½ä¼˜åŒ–ç­‰å„ä¸ªæ–¹é¢ã€‚è®¾è®¡é‡ç‚¹å…³æ³¨ï¼š

1. **é«˜æ€§èƒ½**ï¼šå¤šçº§ç¼“å­˜ã€æ™ºèƒ½ç´¢å¼•ã€æŸ¥è¯¢ä¼˜åŒ–
2. **é«˜å¯é æ€§**ï¼šè‡ªåŠ¨å¤‡ä»½ã€æ•°æ®å®Œæ•´æ€§æ£€æŸ¥ã€æ•…éšœæ¢å¤
3. **é«˜å®‰å…¨æ€§**ï¼šåˆ†å±‚åŠ å¯†ã€è®¿é—®æ§åˆ¶ã€å®¡è®¡æ—¥å¿—
4. **å¯ç»´æŠ¤æ€§**ï¼šè‡ªåŠ¨åŒ–è¿ç»´ã€ç›‘æ§å‘Šè­¦ã€æ€§èƒ½åˆ†æ
5. **å¯æ‰©å±•æ€§**ï¼šæ¨¡å—åŒ–è®¾è®¡ã€æ¥å£æŠ½è±¡ã€æ’ä»¶æ¶æ„

è¯¥è®¾è®¡ä¸ºç³»ç»Ÿçš„æ•°æ®åŸºç¡€è®¾æ–½æä¾›äº†åšå®çš„æŠ€æœ¯ä¿éšœï¼Œç¡®ä¿æ•°æ®çš„å®‰å…¨ã€å¯é å’Œé«˜æ•ˆç®¡ç†ã€‚